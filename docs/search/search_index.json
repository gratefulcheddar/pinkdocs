{
    "docs": [
        {
            "location": "/", 
            "text": "Pinkcoin Developer Documentation\n\n\nWARNING: Incomplete and Inaccurate\n\n\nThis is currently a work in progress. All pages require review. These docs \nwere bootstrapped with the \nBitcoin Developer Reference\n. \nWhile Pinkcoin is a long distant clone of Bitcoin, its codebase is old and \na lot of changes have gone into Bitcoin since. If you would like to \ncontribute in the aid of completing this documentation, please review the \n\nGithub\n.\n\n\nFind Technical Details and API Documentation\n\n\nWelcome to the Pinkcoin developer reference. Due to the similarities \nbetween Bitcoin and Pinkcoin, many parts of this reference were borrowed, \nword for word, from the \nBitcoin Developer Reference\n. \nThis reference aims to provide technical details and API information to \nhelp you start building Pinkcoin-based applications, but it is not a \nspecification.\n\n\nQuestions about Pinkcoin development are best asked in the \n\nPinkcoin Discord\n. Errors or \nsuggestions related to this documentation can be \nsubmitted as an issue\n.\n\n\nNot a Specification\n\n\nThis documentation describes how Pinkcoin works to help educate new \nPinkcoin developers, but it is not a specification - and it never will be.\n\n\nPinkcoin security depends on consensus. Should your program diverge from \nconsensus, its security is weakened or destroyed. The cause of the \ndivergence doesn't matter: it could be a bug in your program, it could be \nan error in this documentation which you implemented as described, or it \ncould be you do everything right but other software on the network behaves \nunexpectedly. The specific cause will not matter to the users of your \nsoftware whose wealth is lost.\n\n\nThe only correct specification of consensus behavior is the actual \nbehavior of the programs on the network which maintain consensus. As that \nbehavior is subject to arbitrary inputs in a large variety of unique \nenvironments, it cannot ever be fully documented here or anywhere else.\n\n\nFurthermore, the documentation has not been extensively reviews by \nPinkcoin experts and so likely contains numerous errors. Please use the \nIssue link on the bottom left menu to help us improve.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#pinkcoin-developer-documentation", 
            "text": "", 
            "title": "Pinkcoin Developer Documentation"
        }, 
        {
            "location": "/#warning-incomplete-and-inaccurate", 
            "text": "This is currently a work in progress. All pages require review. These docs \nwere bootstrapped with the  Bitcoin Developer Reference . \nWhile Pinkcoin is a long distant clone of Bitcoin, its codebase is old and \na lot of changes have gone into Bitcoin since. If you would like to \ncontribute in the aid of completing this documentation, please review the  Github .", 
            "title": "WARNING: Incomplete and Inaccurate"
        }, 
        {
            "location": "/#find-technical-details-and-api-documentation", 
            "text": "Welcome to the Pinkcoin developer reference. Due to the similarities \nbetween Bitcoin and Pinkcoin, many parts of this reference were borrowed, \nword for word, from the  Bitcoin Developer Reference . \nThis reference aims to provide technical details and API information to \nhelp you start building Pinkcoin-based applications, but it is not a \nspecification.  Questions about Pinkcoin development are best asked in the  Pinkcoin Discord . Errors or \nsuggestions related to this documentation can be  submitted as an issue .", 
            "title": "Find Technical Details and API Documentation"
        }, 
        {
            "location": "/#not-a-specification", 
            "text": "This documentation describes how Pinkcoin works to help educate new \nPinkcoin developers, but it is not a specification - and it never will be.  Pinkcoin security depends on consensus. Should your program diverge from \nconsensus, its security is weakened or destroyed. The cause of the \ndivergence doesn't matter: it could be a bug in your program, it could be \nan error in this documentation which you implemented as described, or it \ncould be you do everything right but other software on the network behaves \nunexpectedly. The specific cause will not matter to the users of your \nsoftware whose wealth is lost.  The only correct specification of consensus behavior is the actual \nbehavior of the programs on the network which maintain consensus. As that \nbehavior is subject to arbitrary inputs in a large variety of unique \nenvironments, it cannot ever be fully documented here or anywhere else.  Furthermore, the documentation has not been extensively reviews by \nPinkcoin experts and so likely contains numerous errors. Please use the \nIssue link on the bottom left menu to help us improve.", 
            "title": "Not a Specification"
        }, 
        {
            "location": "/block-chain/", 
            "text": "Block Headers\n\n\nBlock headers are serialized in the 80-byte format described below and then\nhashed as part of Pinkcoin's proof-of-work algorithm, making the\nserialized header format part of the consensus rules.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\nnVersion\n\n\nint\n\n\nThe block version number indicates which set of block validation rules to follow. See the list of block versions below.\n\n\n\n\n\n\n32\n\n\nhashPrevBlock\n\n\nuint256\n\n\nA SHA256(SHA256()) hash in internal byte order of the previous block's header.  This ensures no previous block can be changed without also changing this block's header.\n\n\n\n\n\n\n32\n\n\nhashMerkleRoot\n\n\nuint256\n\n\nA SHA256(SHA256()) hash in internal byte order. The merkle root is derived from the hashes of all transactions included in this block, ensuring that none of those transactions can be modified without modifying the header.  See the merkle trees section below.\n\n\n\n\n\n\n4\n\n\nnTime\n\n\nunsigned int\n\n\nThe block time is a Unix epoch time when the miner started hashing the header (according to the miner).  Must be strictly greater than the median time of the previous 11 blocks.  Full nodes will not accept blocks with headers more than two hours in the future according to their clock.\n\n\n\n\n\n\n4\n\n\nnBits\n\n\nunsigned int\n\n\nAn encoded version of the target threshold this block's header hash must be less than or equal to.  See the nBits format described below.\n\n\n\n\n\n\n4\n\n\nnNonce\n\n\nunsigned int\n\n\nAn arbitrary number miners change to modify the header hash in order to produce a hash less than or equal to the target threshold.  If all 32-bit values are tested, the time can be updated or the coinbase transaction can be changed and the merkle root updated.\n\n\n\n\n\n\n\n\nThe hashes are in internal byte order; the other values are all\nin little-endian order.\n\n\nAn example header in hex:\n\n\n01000000 ........................... Block version: 1\n\nb6ff0b1b1680a2862a30ca44d346d9e8\n910d334beb48ca0c0000000000000000 ... Hash of previous block's header\n9d10aa52ee949386ca9385695f04ede2\n70dda20810decd12bc9b048aaab31471 ... Merkle root\n\n24d95a54 ........................... Unix time: 1415239972\n30c31b18 ........................... Target: 0x1bc330 * 256**(0x18-3)\nfe9f0864 ........................... Nonce\n\n\n\n\nBlock Versions\n\n\n\n\nVersion 1\n was introduced in the genesis block of the current Pinkcoin blockchain (Pinkcoin migrated to this new blockchain on March 8, 2017).\n\n\n\n\nMerkle Trees\n\n\nThe merkle root is constructed using all the TXIDs of transactions in\nthis block, but first the TXIDs are placed in order as required by the\nconsensus rules:\n\n\n\n\n\n\nThe coinbase transaction's TXID is always placed first.\n\n\n\n\n\n\nAny input within this block can spend an output which also appears in\n  this block (assuming the spend is otherwise valid). However, the TXID\n  corresponding to the output must be placed at some point before the\n  TXID corresponding to the input. This ensures that any program parsing\n  block chain transactions linearly will encounter each output before it\n  is used as an input.\n\n\n\n\n\n\nIf a block only has a coinbase transaction, the coinbase TXID is used as\nthe merkle root hash.\n\n\nIf a block only has a coinbase transaction and one other transaction,\nthe TXIDs of those two transactions are placed in order, concatenated as\n64 raw bytes, and then SHA256(SHA256()) hashed together to form the\nmerkle root.\n\n\nIf a block has three or more transactions, intermediate merkle tree rows\nare formed. The TXIDs are placed in order and paired, starting with the\ncoinbase transaction's TXID. Each pair is concatenated together as 64\nraw bytes and SHA256(SHA256()) hashed to form a second row of\nhashes. If there are an odd (non-even) number of TXIDs, the last TXID is\nconcatenated with a copy of itself and hashed. If there are more than\ntwo hashes in the second row, the process is repeated to create a third\nrow (and, if necessary, repeated further to create additional rows).\nOnce a row is obtained with only two hashes, those hashes are concatenated and\nhashed to produce the merkle root..\n\n\n\n\nTXIDs and intermediate hashes are always in internal byte order when they're\nconcatenated, and the resulting merkle root is also in internal byte\norder when it's placed in the block header.\n\n\nTarget nBits\n\n\nThe target threshold is a 256-bit unsigned integer which a header hash\nmust be equal to or below in order for that header to be a valid part of\nthe block chain.\nHowever, the header field \nnBits\n provides only 32 bits of space, so the\ntarget number uses a less precise format called \"compact\" which works\nlike a base-256 version of scientific notation:\n\n\n\n\nAs a base-256 number, nBits can be quickly parsed as bytes the same way\nyou might parse a decimal number in base-10 scientific notation:\n\n\n\n\nAlthough the target threshold should be an unsigned integer, the\noriginal nBits implementation inherits properties from a signed data\nclass, allowing the target threshold to be negative if the high bit of\nthe significand is set. This is useless---the header hash is\ntreated as an unsigned number, so it can never be equal to or lower than a\nnegative target threshold. Pinkcoin Core deals with this in two ways:\n\n\n\n\n\n\nWhen parsing nBits, Pinkcoin Core converts a negative target\n  threshold into a target of zero, which the header hash can equal (in\n  theory, at least).\n\n\n\n\n\n\nWhen creating a value for nBits, Pinkcoin Core checks to see if it will\n  produce an nBits which will be interpreted as negative; if so, it\n  divides the significand by 256 and increases the exponent by 1 to\n  produce the same number with a different encoding.\n\n\n\n\n\n\nSome examples taken from the Pinkcoin Core test cases:\n\n\n\n\n\n\n\n\nnBits\n\n\nTarget\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\n0x01003456\n\n\n0x00\n\n\n\n\n\n\n\n\n0x01123456\n\n\n0x12\n\n\n\n\n\n\n\n\n0x02008000\n\n\n0x80\n\n\n\n\n\n\n\n\n0x05009234\n\n\n0x92340000\n\n\n\n\n\n\n\n\n0x04923456\n\n\n-0x12345600\n\n\nHigh bit set (0x80 in 0x92).\n\n\n\n\n\n\n0x04123456\n\n\n0x12345600\n\n\nInverse of above; no high bit.\n\n\n\n\n\n\n\n\nDifficulty 1, the minimum allowed difficulty, is represented on mainnet\nand the current testnet by the nBits value 0x1d00ffff. Regtest mode uses\na different difficulty 1 value---0x207fffff, the highest possible value\nbelow uint32_max which can be encoded; this allows near-instant building\nof blocks in regtest mode.\n\n\nSerialized Blocks\n\n\nUnder current consensus rules, a block is not valid unless its\nserialized size is less than or equal to 1 MB. All fields described\nbelow are counted towards the serialized size.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n80\n\n\nblock header\n\n\nblock_header\n\n\nThe block header in the format described in the \nblock header section\n.\n\n\n\n\n\n\nVaries\n\n\ntxn_count\n\n\ncompactSize uint\n\n\nThe total number of transactions in this block, including the coinbase transaction.\n\n\n\n\n\n\nVaries\n\n\ntxns\n\n\nraw transaction\n\n\nEvery transaction in this block, one after another, in raw transaction format.  Transactions must appear in the data stream in the same order their TXIDs appeared in the first row of the merkle tree.  See the \nmerkle tree section\n for details.\n\n\n\n\n\n\n\n\nThe first transaction in a block must be a coinbase\ntransaction which should collect and\nspend any transaction fees paid by transactions included in this block.\n\n\nAll blocks with a block height less than 6,930,000 are entitled to\nreceive a block subsidy of newly created pinkcoin value, which also\nshould be spent in the coinbase transaction. (The block subsidy started\nat 50 pinkcoins and is being halved every 210,000 blocks---approximately\nonce every four years. As of November 2017, it's 12.5 pinkcoins.)\n\n\nTogether, the transaction fees and block subsidy are called the block\nreward. A coinbase transaction is\ninvalid if it tries to spend more value than is available from the\nblock reward.", 
            "title": "Blockchain"
        }, 
        {
            "location": "/block-chain/#block-headers", 
            "text": "Block headers are serialized in the 80-byte format described below and then\nhashed as part of Pinkcoin's proof-of-work algorithm, making the\nserialized header format part of the consensus rules.     Bytes  Name  Data Type  Description      4  nVersion  int  The block version number indicates which set of block validation rules to follow. See the list of block versions below.    32  hashPrevBlock  uint256  A SHA256(SHA256()) hash in internal byte order of the previous block's header.  This ensures no previous block can be changed without also changing this block's header.    32  hashMerkleRoot  uint256  A SHA256(SHA256()) hash in internal byte order. The merkle root is derived from the hashes of all transactions included in this block, ensuring that none of those transactions can be modified without modifying the header.  See the merkle trees section below.    4  nTime  unsigned int  The block time is a Unix epoch time when the miner started hashing the header (according to the miner).  Must be strictly greater than the median time of the previous 11 blocks.  Full nodes will not accept blocks with headers more than two hours in the future according to their clock.    4  nBits  unsigned int  An encoded version of the target threshold this block's header hash must be less than or equal to.  See the nBits format described below.    4  nNonce  unsigned int  An arbitrary number miners change to modify the header hash in order to produce a hash less than or equal to the target threshold.  If all 32-bit values are tested, the time can be updated or the coinbase transaction can be changed and the merkle root updated.     The hashes are in internal byte order; the other values are all\nin little-endian order.  An example header in hex:  01000000 ........................... Block version: 1\n\nb6ff0b1b1680a2862a30ca44d346d9e8\n910d334beb48ca0c0000000000000000 ... Hash of previous block's header\n9d10aa52ee949386ca9385695f04ede2\n70dda20810decd12bc9b048aaab31471 ... Merkle root\n\n24d95a54 ........................... Unix time: 1415239972\n30c31b18 ........................... Target: 0x1bc330 * 256**(0x18-3)\nfe9f0864 ........................... Nonce", 
            "title": "Block Headers"
        }, 
        {
            "location": "/block-chain/#block-versions", 
            "text": "Version 1  was introduced in the genesis block of the current Pinkcoin blockchain (Pinkcoin migrated to this new blockchain on March 8, 2017).", 
            "title": "Block Versions"
        }, 
        {
            "location": "/block-chain/#merkle-trees", 
            "text": "The merkle root is constructed using all the TXIDs of transactions in\nthis block, but first the TXIDs are placed in order as required by the\nconsensus rules:    The coinbase transaction's TXID is always placed first.    Any input within this block can spend an output which also appears in\n  this block (assuming the spend is otherwise valid). However, the TXID\n  corresponding to the output must be placed at some point before the\n  TXID corresponding to the input. This ensures that any program parsing\n  block chain transactions linearly will encounter each output before it\n  is used as an input.    If a block only has a coinbase transaction, the coinbase TXID is used as\nthe merkle root hash.  If a block only has a coinbase transaction and one other transaction,\nthe TXIDs of those two transactions are placed in order, concatenated as\n64 raw bytes, and then SHA256(SHA256()) hashed together to form the\nmerkle root.  If a block has three or more transactions, intermediate merkle tree rows\nare formed. The TXIDs are placed in order and paired, starting with the\ncoinbase transaction's TXID. Each pair is concatenated together as 64\nraw bytes and SHA256(SHA256()) hashed to form a second row of\nhashes. If there are an odd (non-even) number of TXIDs, the last TXID is\nconcatenated with a copy of itself and hashed. If there are more than\ntwo hashes in the second row, the process is repeated to create a third\nrow (and, if necessary, repeated further to create additional rows).\nOnce a row is obtained with only two hashes, those hashes are concatenated and\nhashed to produce the merkle root..   TXIDs and intermediate hashes are always in internal byte order when they're\nconcatenated, and the resulting merkle root is also in internal byte\norder when it's placed in the block header.", 
            "title": "Merkle Trees"
        }, 
        {
            "location": "/block-chain/#target-nbits", 
            "text": "The target threshold is a 256-bit unsigned integer which a header hash\nmust be equal to or below in order for that header to be a valid part of\nthe block chain.\nHowever, the header field  nBits  provides only 32 bits of space, so the\ntarget number uses a less precise format called \"compact\" which works\nlike a base-256 version of scientific notation:   As a base-256 number, nBits can be quickly parsed as bytes the same way\nyou might parse a decimal number in base-10 scientific notation:   Although the target threshold should be an unsigned integer, the\noriginal nBits implementation inherits properties from a signed data\nclass, allowing the target threshold to be negative if the high bit of\nthe significand is set. This is useless---the header hash is\ntreated as an unsigned number, so it can never be equal to or lower than a\nnegative target threshold. Pinkcoin Core deals with this in two ways:    When parsing nBits, Pinkcoin Core converts a negative target\n  threshold into a target of zero, which the header hash can equal (in\n  theory, at least).    When creating a value for nBits, Pinkcoin Core checks to see if it will\n  produce an nBits which will be interpreted as negative; if so, it\n  divides the significand by 256 and increases the exponent by 1 to\n  produce the same number with a different encoding.    Some examples taken from the Pinkcoin Core test cases:     nBits  Target  Notes      0x01003456  0x00     0x01123456  0x12     0x02008000  0x80     0x05009234  0x92340000     0x04923456  -0x12345600  High bit set (0x80 in 0x92).    0x04123456  0x12345600  Inverse of above; no high bit.     Difficulty 1, the minimum allowed difficulty, is represented on mainnet\nand the current testnet by the nBits value 0x1d00ffff. Regtest mode uses\na different difficulty 1 value---0x207fffff, the highest possible value\nbelow uint32_max which can be encoded; this allows near-instant building\nof blocks in regtest mode.", 
            "title": "Target nBits"
        }, 
        {
            "location": "/block-chain/#serialized-blocks", 
            "text": "Under current consensus rules, a block is not valid unless its\nserialized size is less than or equal to 1 MB. All fields described\nbelow are counted towards the serialized size.     Bytes  Name  Data Type  Description      80  block header  block_header  The block header in the format described in the  block header section .    Varies  txn_count  compactSize uint  The total number of transactions in this block, including the coinbase transaction.    Varies  txns  raw transaction  Every transaction in this block, one after another, in raw transaction format.  Transactions must appear in the data stream in the same order their TXIDs appeared in the first row of the merkle tree.  See the  merkle tree section  for details.     The first transaction in a block must be a coinbase\ntransaction which should collect and\nspend any transaction fees paid by transactions included in this block.  All blocks with a block height less than 6,930,000 are entitled to\nreceive a block subsidy of newly created pinkcoin value, which also\nshould be spent in the coinbase transaction. (The block subsidy started\nat 50 pinkcoins and is being halved every 210,000 blocks---approximately\nonce every four years. As of November 2017, it's 12.5 pinkcoins.)  Together, the transaction fees and block subsidy are called the block\nreward. A coinbase transaction is\ninvalid if it tries to spend more value than is available from the\nblock reward.", 
            "title": "Serialized Blocks"
        }, 
        {
            "location": "/transactions/", 
            "text": "OpCodes\n\n\nThe opcodes used in the pubkey scripts of standard transactions are:\n\n\n\n\n\n\nVarious data pushing opcodes from 0x00 to 0x4e (1--78). These aren't\n  typically shown in examples, but they must be used to push\n  signatures and public keys onto the stack.\n\n\n\n\n\n\nOP_TRUE\n/\nOP_1\n (0x51) and \nOP_2\n through \nOP_16\n (0x52--0x60), which\n  push the values 1 through 16 to the stack.\n\n\n\n\n\n\nOP_CHECKSIG\n consumes a signature and a full public key, and pushes\n  true onto the stack if the transaction data specified by the SIGHASH flag was\n  converted into the signature using the same ECDSA private key that\n  generated the public key.  Otherwise, it pushes false onto the stack.\n\n\n\n\n\n\nOP_DUP\n pushes a copy of the topmost stack item on to the stack.\n\n\n\n\n\n\nOP_HASH160\n consumes the topmost item on the stack,\n  computes the RIPEMD160(SHA256()) hash of that item, and pushes that hash onto the stack.\n\n\n\n\n\n\nOP_EQUAL\n consumes the top two items on the stack, compares them, and\n  pushes true onto the stack if they are the same, false if not.\n\n\n\n\n\n\nOP_VERIFY\n consumes the topmost item on the stack.\n  If that item is zero (false) it terminates the script in failure.\n\n\n\n\n\n\nOP_EQUALVERIFY\n runs \nOP_EQUAL\n and then \nOP_VERIFY\n in sequence.\n\n\n\n\n\n\nOP_CHECKMULTISIG\n consumes the value (n) at the top of the stack,\n  consumes that many of the next stack levels (public keys), consumes\n  the value (m) now at the top of the stack, and consumes that many of\n  the next values (signatures) plus one extra value.\n\n\nThe \"one extra value\" it consumes is the result of an off-by-one\nerror in the Bitcoin Core implementation. This value is not used, so\nsignature scripts prefix the list of secp256k1 signatures with a\nsingle OP_0 (0x00).\n\n\nOP_CHECKMULTISIG\n compares the first signature against each public\nkey until it finds an ECDSA match. Starting with the subsequent\npublic key, it compares the second signature against each remaining\npublic key until it finds an ECDSA match. The process is repeated\nuntil all signatures have been checked or not enough public keys\nremain to produce a successful result.\n\n\nBecause public keys are not checked again if they fail any signature\ncomparison, signatures must be placed in the signature script using\nthe same order as their corresponding public keys were placed in\nthe pubkey script or redeem script. See the \nOP_CHECKMULTISIG\n warning\nbelow for more details.\n\n\n\n\n\n\nOP_RETURN\n terminates the script in failure when executed.\n\n\n\n\n\n\nA complete list of opcodes can be found in the \nopcodetype\n enum\nof the Pinkcoin script header file (script.h).\n\n\n\n\nSignature script modification warning:\n\nSignature scripts are not signed, so anyone can modify them. This\nmeans signature scripts should only contain data and data-pushing opcodes\nwhich can't be modified without causing the pubkey script to fail.\nPlacing non-data-pushing opcodes in the signature script currently\nmakes a transaction non-standard, and future consensus rules may forbid\nsuch transactions altogether. (Non-data-pushing opcodes are already\nforbidden in signature scripts when spending a P2SH pubkey script.)\n\n\n\n\nOP_CHECKMULTISIG\n warning:\n The multisig verification process\ndescribed above requires that signatures in the signature script be\nprovided in the same order as their corresponding public keys in\nthe pubkey script or redeem script. For example, the following\ncombined signature and pubkey script will produce the stack and\ncomparisons shown:\n\n\nOP_0 \nA sig\n \nB sig\n OP_2 \nA pubkey\n \nB pubkey\n \nC pubkey\n OP_3\n\nSig Stack       Pubkey Stack  (Actually a single stack)\n---------       ------------\nB sig           C pubkey\nA sig           B pubkey\nOP_0            A pubkey\n\n1. B sig compared to C pubkey (no match)\n2. B sig compared to B pubkey (match #1)\n3. A sig compared to A pubkey (match #2)\n\nSuccess: two matches found\n\n\n\n\nBut reversing the order of the signatures with everything else the same\nwill fail, as shown below:\n\n\nOP_0 \nB sig\n \nA sig\n OP_2 \nA pubkey\n \nB pubkey\n \nC pubkey\n OP_3\n\nSig Stack       Pubkey Stack  (Actually a single stack)\n---------       ------------\nA sig           C pubkey\nB sig           B pubkey\nOP_0            A pubkey\n\n1. A sig compared to C pubkey (no match)\n2. A sig compared to B pubkey (no match)\n\nFailure, aborted: two signature matches required but none found so\n                  far, and there's only one pubkey remaining\n\n\n\n\nAddress Conversion\n\n\nThe hashes used in P2PKH and P2SH outputs are commonly encoded as Bitcoin\naddresses.  This is the procedure to encode those hashes and decode the\naddresses.\n\n\nFirst, get your hash.  For P2PKH, you RIPEMD-160(SHA256()) hash a ECDSA\npublic key derived from your 256-bit ECDSA private key (random data).\nFor P2SH, you RIPEMD-160(SHA256()) hash a redeem script serialized in the\nformat used in raw transactions (described in a [following\nsub-section][raw transaction format]).  Taking the resulting hash:\n\n\n\n\n\n\nAdd an address version byte in front of the hash.  The version\nbytes commonly used by Pinkcoin are:\n\n\n\n\n\n\n0x03 for P2PKH addresses on the main Pinkcoin network (mainnet)\n\n\n\n\n\n\n0x37 for P2PKH addresses on the Pinkcoin testing network (testnet)\n\n\n\n\n\n\n0x1c for P2SH addresses on mainnet\n\n\n\n\n\n\n0xc4 for P2SH addresses on testnet\n\n\n\n\n\n\n\n\n\n\nCreate a copy of the version and hash; then hash that twice with SHA256: \nSHA256(SHA256(version . hash))\n\n\n\n\n\n\nExtract the first four bytes from the double-hashed copy.\n   These are used as a checksum to ensure the base hash gets transmitted\n   correctly.\n\n\n\n\n\n\nAppend the checksum to the version and hash, and encode it as a base58\n   string: \nBASE58(version . hash . checksum)\n\n\n\n\n\n\nPinkcoin's own code can be traced using the base58 header\nfile.\nTo convert addresses back into hashes, reverse the base58 encoding, extract\nthe checksum, repeat the steps to create the checksum and compare it\nagainst the extracted checksum, and then remove the version byte.\n\n\nRaw Transaction Format\n\n\nBitcoin transactions are broadcast between peers\nin a serialized byte format, called raw format.\nIt is this form of a transaction which is SHA256(SHA256()) hashed to create\nthe TXID and, ultimately, the merkle root of a block containing the\ntransaction---making the transaction format part of the consensus rules.\n\n\nBitcoin Core and many other tools print and accept raw transactions\nencoded as hex.\n\n\nAs of Bitcoin Core 0.9.3 (October 2014), all transactions use the\nversion 1 format described below. (Note: transactions in the block chain\nare allowed to list a higher version number to permit soft forks, but\nthey are treated as version 1 transactions by current software.)\n\n\nA raw transaction has the following top-level format:\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\nversion\n\n\nuint32_t\n\n\nTransaction version number; currently version 1.  Programs creating transactions using newer consensus rules may use higher version numbers.\n\n\n\n\n\n\nVaries\n\n\ntx_in count\n\n\ncompactSize uint\n\n\nNumber of inputs in this transaction.\n\n\n\n\n\n\nVaries\n\n\ntx_in\n\n\ntxIn\n\n\nTransaction inputs.  See description of txIn below.\n\n\n\n\n\n\nVaries\n\n\ntx_out count\n\n\ncompactSize uint\n\n\nNumber of outputs in this transaction.\n\n\n\n\n\n\nVaries\n\n\ntx_out\n\n\ntxOut\n\n\nTransaction outputs.  See description of txOut below.\n\n\n\n\n\n\n4\n\n\nlock_time\n\n\nuint32_t\n\n\nA time (Unix epoch time) or block number.  See the locktime parsing rules.\n\n\n\n\n\n\n\n\nA transaction may have multiple inputs and outputs, so the txIn and\ntxOut structures may recur within a transaction. CompactSize unsigned\nintegers are a form of variable-length integers; they are described in\nthe CompactSize section.\n\n\nTxIn: A Transaction Input (Non-Coinbase) {#txin}\n\n\nEach non-coinbase input spends an outpoint from a previous transaction.\n(Coinbase inputs are described separately after the example section below.)\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n36\n\n\nprevious_output\n\n\noutpoint\n\n\nThe previous outpoint being spent.  See description of outpoint below.\n\n\n\n\n\n\nVaries\n\n\nscript bytes\n\n\ncompactSize uint\n\n\nThe number of bytes in the signature script.  Maximum is 10,000 bytes.\n\n\n\n\n\n\nVaries\n\n\nsignature script\n\n\nchar[]\n\n\nA script-language script which satisfies the conditions placed in the outpoint's pubkey script.  Should only contain data pushes; see the [signature script modification warning][].\n\n\n\n\n\n\n4\n\n\nsequence\n\n\nuint32_t\n\n\nSequence number.  Default for Bitcoin Core and almost all other programs is 0xffffffff.\n\n\n\n\n\n\n\n\nOutpoint: The Specific Part Of A Specific Output {#outpoint}\n\n\nBecause a single transaction can include multiple outputs, the outpoint\nstructure includes both a TXID and an output index number to refer to\nspecific output.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n32\n\n\nhash\n\n\nchar[32]\n\n\nThe TXID of the transaction holding the output to spend.  The TXID is a hash provided here in internal byte order.\n\n\n\n\n\n\n4\n\n\nindex\n\n\nuint32_t\n\n\nThe output index number of the specific output to spend from the transaction. The first output is 0x00000000.\n\n\n\n\n\n\n\n\nTxOut: A Transaction Output {#txout}\n\n\nEach output spends a certain number of satoshis, placing them under\ncontrol of anyone who can satisfy the provided pubkey script.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n8\n\n\nvalue\n\n\nint64_t\n\n\nNumber of satoshis to spend.  May be zero; the sum of all outputs may not exceed the sum of satoshis previously spent to the outpoints provided in the input section.  (Exception: coinbase transactions spend the block subsidy and collected transaction fees.)\n\n\n\n\n\n\n1+\n\n\npk_script bytes\n\n\ncompactSize uint\n\n\nNumber of bytes in the pubkey script.  Maximum is 10,000 bytes.\n\n\n\n\n\n\nVaries\n\n\npk_script\n\n\nchar[]\n\n\nDefines the conditions which must be satisfied to spend this output.\n\n\n\n\n\n\n\n\nExample\n\n\nThe sample raw transaction itemized below is the one created in the\nSimple Raw Transaction section of the\nDeveloper Examples. It spends a previous pay-to-pubkey output by paying\nto a new pay-to-pubkey-hash (P2PKH) output.\n\n\n01000000 ................................... Version\n\n01 ......................................... Number of inputs\n|\n| 7b1eabe0209b1fe794124575ef807057\n| c77ada2138ae4fa8d6c4de0398a14f3f ......... Outpoint TXID\n| 00000000 ................................. Outpoint index number\n|\n| 49 ....................................... Bytes in sig. script: 73\n| | 48 ..................................... Push 72 bytes as data\n| | | 30450221008949f0cb400094ad2b5eb3\n| | | 99d59d01c14d73d8fe6e96df1a7150de\n| | | b388ab8935022079656090d7f6bac4c9\n| | | a94e0aad311a4268e082a725f8aeae05\n| | | 73fb12ff866a5f01 ..................... Secp256k1 signature\n|\n| ffffffff ................................. Sequence number: UINT32_MAX\n\n01 ......................................... Number of outputs\n| f0ca052a01000000 ......................... Satoshis (49.99990000 BTC)\n|\n| 19 ....................................... Bytes in pubkey script: 25\n| | 76 ..................................... OP_DUP\n| | a9 ..................................... OP_HASH160\n| | 14 ..................................... Push 20 bytes as data\n| | | cbc20a7664f2f69e5355aa427045bc15\n| | | e7c6c772 ............................. PubKey hash\n| | 88 ..................................... OP_EQUALVERIFY\n| | ac ..................................... OP_CHECKSIG\n\n00000000 ................................... locktime: 0 (a block height)\n\n\n\n\nCoinbase Input: The Input Of The First Transaction In A Block {#coinbase}\n\n\nThe first transaction in a block, called the coinbase transaction, must\nhave exactly one input, called a coinbase. The coinbase input currently\nhas the following format.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n32\n\n\nhash (null)\n\n\nchar[32]\n\n\nA 32-byte null, as a coinbase has no previous outpoint.\n\n\n\n\n\n\n4\n\n\nindex (UINT32_MAX)\n\n\nuint32_t\n\n\n0xffffffff, as a coinbase has no previous outpoint.\n\n\n\n\n\n\nVaries\n\n\nscript bytes\n\n\ncompactSize uint\n\n\nThe number of bytes in the coinbase script, up to a maximum of 100 bytes.\n\n\n\n\n\n\nVaries\n (4)\n\n\nheight\n\n\nscript\n\n\nThe block height of this block as required by BIP34.  Uses script language: starts with a data-pushing opcode that indicates how many bytes to push to the stack followed by the block height as a little-endian unsigned integer.  This script must be as short as possible, otherwise it may be rejected.\n  The data-pushing opcode will be 0x03 and the total size four bytes until block 16,777,216 about 300 years from now.\n\n\n\n\n\n\nVaries\n\n\ncoinbase script\n\n\nNone\n\n\nThe coinbase field Arbitrary data not exceeding 100 bytes minus the (4) height bytes.  Miners commonly place an extra nonce in this field to update the block header merkle root during hashing.\n\n\n\n\n\n\n4\n\n\nsequence\n\n\nuint32_t\n\n\nSequence number.\n\n\n\n\n\n\n\n\nMost (but not all) blocks prior to block height 227,836 used block\nversion 1 which did not require the height parameter to be prefixed to\nthe coinbase script.  The block height parameter is now required.\n\n\nAlthough the coinbase script is arbitrary data, if it includes the\nbytes used by any signature-checking operations such as \nOP_CHECKSIG\n,\nthose signature checks will be counted as signature operations (sigops)\ntowards the block's sigop limit.  To avoid this, you can prefix all data\nwith the appropriate push operation.\n\n\nAn itemized coinbase transaction:\n\n\n01000000 .............................. Version\n\n01 .................................... Number of inputs\n| 00000000000000000000000000000000\n| 00000000000000000000000000000000 ...  Previous outpoint TXID\n| ffffffff ............................ Previous outpoint index\n|\n| 29 .................................. Bytes in coinbase\n| |\n| | 03 ................................ Bytes in height\n| | | 4e0105 .......................... Height: 328014\n| |\n| | 062f503253482f0472d35454085fffed\n| | f2400000f90f54696d65202620486561\n| | 6c74682021 ........................ Arbitrary data\n| 00000000 ............................ Sequence\n\n01 .................................... Output count\n| 2c37449500000000 .................... Satoshis (25.04275756 BTC)\n| 1976a914a09be8040cbf399926aeb1f4\n| 70c37d1341f3b46588ac ................ P2PKH script\n| 00000000 ............................ Locktime\n\n\n\n\nCompactSize Unsigned Integers\n\n\nThe raw transaction format and several peer-to-peer network messages use\na type of variable-length integer to indicate the number of bytes in a\nfollowing piece of data.\n\n\nBitcoin Core code and this document refers to these variable length\nintegers as compactSize. Many other documents refer to them as var_int\nor varInt, but this risks conflation with other variable-length integer\nencodings---such as the CVarInt class used in Bitcoin Core for\nserializing data to disk.  Because it's used in the transaction format,\nthe format of compactSize unsigned integers is part of the consensus\nrules.\n\n\nFor numbers from 0 to 252, compactSize unsigned integers look like\nregular unsigned integers. For other numbers up to 0xffffffffffffffff, a\nbyte is prefixed to the number to indicate its length---but otherwise\nthe numbers look like regular unsigned integers in little-endian order.\n\n\n\n\n\n\n\n\nValue\n\n\nBytes Used\n\n\nFormat\n\n\n\n\n\n\n\n\n\n\n= 0 \n \n= 252\n\n\n1\n\n\nuint8_t\n\n\n\n\n\n\n= 253 \n \n= 0xffff\n\n\n3\n\n\n0xfd followed by the number as uint16_t\n\n\n\n\n\n\n= 0x10000 \n \n= 0xffffffff\n\n\n5\n\n\n0xfe followed by the number as uint32_t\n\n\n\n\n\n\n= 0x100000000 \n \n= 0xffffffffffffffff\n\n\n9\n\n\n0xff followed by the number as uint64_t\n\n\n\n\n\n\n\n\nFor example, the number 515 is encoded as 0xfd0302.", 
            "title": "Transactions"
        }, 
        {
            "location": "/transactions/#opcodes", 
            "text": "The opcodes used in the pubkey scripts of standard transactions are:    Various data pushing opcodes from 0x00 to 0x4e (1--78). These aren't\n  typically shown in examples, but they must be used to push\n  signatures and public keys onto the stack.    OP_TRUE / OP_1  (0x51) and  OP_2  through  OP_16  (0x52--0x60), which\n  push the values 1 through 16 to the stack.    OP_CHECKSIG  consumes a signature and a full public key, and pushes\n  true onto the stack if the transaction data specified by the SIGHASH flag was\n  converted into the signature using the same ECDSA private key that\n  generated the public key.  Otherwise, it pushes false onto the stack.    OP_DUP  pushes a copy of the topmost stack item on to the stack.    OP_HASH160  consumes the topmost item on the stack,\n  computes the RIPEMD160(SHA256()) hash of that item, and pushes that hash onto the stack.    OP_EQUAL  consumes the top two items on the stack, compares them, and\n  pushes true onto the stack if they are the same, false if not.    OP_VERIFY  consumes the topmost item on the stack.\n  If that item is zero (false) it terminates the script in failure.    OP_EQUALVERIFY  runs  OP_EQUAL  and then  OP_VERIFY  in sequence.    OP_CHECKMULTISIG  consumes the value (n) at the top of the stack,\n  consumes that many of the next stack levels (public keys), consumes\n  the value (m) now at the top of the stack, and consumes that many of\n  the next values (signatures) plus one extra value.  The \"one extra value\" it consumes is the result of an off-by-one\nerror in the Bitcoin Core implementation. This value is not used, so\nsignature scripts prefix the list of secp256k1 signatures with a\nsingle OP_0 (0x00).  OP_CHECKMULTISIG  compares the first signature against each public\nkey until it finds an ECDSA match. Starting with the subsequent\npublic key, it compares the second signature against each remaining\npublic key until it finds an ECDSA match. The process is repeated\nuntil all signatures have been checked or not enough public keys\nremain to produce a successful result.  Because public keys are not checked again if they fail any signature\ncomparison, signatures must be placed in the signature script using\nthe same order as their corresponding public keys were placed in\nthe pubkey script or redeem script. See the  OP_CHECKMULTISIG  warning\nbelow for more details.    OP_RETURN  terminates the script in failure when executed.    A complete list of opcodes can be found in the  opcodetype  enum\nof the Pinkcoin script header file (script.h).   Signature script modification warning: \nSignature scripts are not signed, so anyone can modify them. This\nmeans signature scripts should only contain data and data-pushing opcodes\nwhich can't be modified without causing the pubkey script to fail.\nPlacing non-data-pushing opcodes in the signature script currently\nmakes a transaction non-standard, and future consensus rules may forbid\nsuch transactions altogether. (Non-data-pushing opcodes are already\nforbidden in signature scripts when spending a P2SH pubkey script.)   OP_CHECKMULTISIG  warning:  The multisig verification process\ndescribed above requires that signatures in the signature script be\nprovided in the same order as their corresponding public keys in\nthe pubkey script or redeem script. For example, the following\ncombined signature and pubkey script will produce the stack and\ncomparisons shown:  OP_0  A sig   B sig  OP_2  A pubkey   B pubkey   C pubkey  OP_3\n\nSig Stack       Pubkey Stack  (Actually a single stack)\n---------       ------------\nB sig           C pubkey\nA sig           B pubkey\nOP_0            A pubkey\n\n1. B sig compared to C pubkey (no match)\n2. B sig compared to B pubkey (match #1)\n3. A sig compared to A pubkey (match #2)\n\nSuccess: two matches found  But reversing the order of the signatures with everything else the same\nwill fail, as shown below:  OP_0  B sig   A sig  OP_2  A pubkey   B pubkey   C pubkey  OP_3\n\nSig Stack       Pubkey Stack  (Actually a single stack)\n---------       ------------\nA sig           C pubkey\nB sig           B pubkey\nOP_0            A pubkey\n\n1. A sig compared to C pubkey (no match)\n2. A sig compared to B pubkey (no match)\n\nFailure, aborted: two signature matches required but none found so\n                  far, and there's only one pubkey remaining", 
            "title": "OpCodes"
        }, 
        {
            "location": "/transactions/#address-conversion", 
            "text": "The hashes used in P2PKH and P2SH outputs are commonly encoded as Bitcoin\naddresses.  This is the procedure to encode those hashes and decode the\naddresses.  First, get your hash.  For P2PKH, you RIPEMD-160(SHA256()) hash a ECDSA\npublic key derived from your 256-bit ECDSA private key (random data).\nFor P2SH, you RIPEMD-160(SHA256()) hash a redeem script serialized in the\nformat used in raw transactions (described in a [following\nsub-section][raw transaction format]).  Taking the resulting hash:    Add an address version byte in front of the hash.  The version\nbytes commonly used by Pinkcoin are:    0x03 for P2PKH addresses on the main Pinkcoin network (mainnet)    0x37 for P2PKH addresses on the Pinkcoin testing network (testnet)    0x1c for P2SH addresses on mainnet    0xc4 for P2SH addresses on testnet      Create a copy of the version and hash; then hash that twice with SHA256:  SHA256(SHA256(version . hash))    Extract the first four bytes from the double-hashed copy.\n   These are used as a checksum to ensure the base hash gets transmitted\n   correctly.    Append the checksum to the version and hash, and encode it as a base58\n   string:  BASE58(version . hash . checksum)    Pinkcoin's own code can be traced using the base58 header\nfile.\nTo convert addresses back into hashes, reverse the base58 encoding, extract\nthe checksum, repeat the steps to create the checksum and compare it\nagainst the extracted checksum, and then remove the version byte.", 
            "title": "Address Conversion"
        }, 
        {
            "location": "/transactions/#raw-transaction-format", 
            "text": "Bitcoin transactions are broadcast between peers\nin a serialized byte format, called raw format.\nIt is this form of a transaction which is SHA256(SHA256()) hashed to create\nthe TXID and, ultimately, the merkle root of a block containing the\ntransaction---making the transaction format part of the consensus rules.  Bitcoin Core and many other tools print and accept raw transactions\nencoded as hex.  As of Bitcoin Core 0.9.3 (October 2014), all transactions use the\nversion 1 format described below. (Note: transactions in the block chain\nare allowed to list a higher version number to permit soft forks, but\nthey are treated as version 1 transactions by current software.)  A raw transaction has the following top-level format:     Bytes  Name  Data Type  Description      4  version  uint32_t  Transaction version number; currently version 1.  Programs creating transactions using newer consensus rules may use higher version numbers.    Varies  tx_in count  compactSize uint  Number of inputs in this transaction.    Varies  tx_in  txIn  Transaction inputs.  See description of txIn below.    Varies  tx_out count  compactSize uint  Number of outputs in this transaction.    Varies  tx_out  txOut  Transaction outputs.  See description of txOut below.    4  lock_time  uint32_t  A time (Unix epoch time) or block number.  See the locktime parsing rules.     A transaction may have multiple inputs and outputs, so the txIn and\ntxOut structures may recur within a transaction. CompactSize unsigned\nintegers are a form of variable-length integers; they are described in\nthe CompactSize section.", 
            "title": "Raw Transaction Format"
        }, 
        {
            "location": "/transactions/#txin-a-transaction-input-non-coinbase-txin", 
            "text": "Each non-coinbase input spends an outpoint from a previous transaction.\n(Coinbase inputs are described separately after the example section below.)     Bytes  Name  Data Type  Description      36  previous_output  outpoint  The previous outpoint being spent.  See description of outpoint below.    Varies  script bytes  compactSize uint  The number of bytes in the signature script.  Maximum is 10,000 bytes.    Varies  signature script  char[]  A script-language script which satisfies the conditions placed in the outpoint's pubkey script.  Should only contain data pushes; see the [signature script modification warning][].    4  sequence  uint32_t  Sequence number.  Default for Bitcoin Core and almost all other programs is 0xffffffff.", 
            "title": "TxIn: A Transaction Input (Non-Coinbase) {#txin}"
        }, 
        {
            "location": "/transactions/#outpoint-the-specific-part-of-a-specific-output-outpoint", 
            "text": "Because a single transaction can include multiple outputs, the outpoint\nstructure includes both a TXID and an output index number to refer to\nspecific output.     Bytes  Name  Data Type  Description      32  hash  char[32]  The TXID of the transaction holding the output to spend.  The TXID is a hash provided here in internal byte order.    4  index  uint32_t  The output index number of the specific output to spend from the transaction. The first output is 0x00000000.", 
            "title": "Outpoint: The Specific Part Of A Specific Output {#outpoint}"
        }, 
        {
            "location": "/transactions/#txout-a-transaction-output-txout", 
            "text": "Each output spends a certain number of satoshis, placing them under\ncontrol of anyone who can satisfy the provided pubkey script.     Bytes  Name  Data Type  Description      8  value  int64_t  Number of satoshis to spend.  May be zero; the sum of all outputs may not exceed the sum of satoshis previously spent to the outpoints provided in the input section.  (Exception: coinbase transactions spend the block subsidy and collected transaction fees.)    1+  pk_script bytes  compactSize uint  Number of bytes in the pubkey script.  Maximum is 10,000 bytes.    Varies  pk_script  char[]  Defines the conditions which must be satisfied to spend this output.     Example  The sample raw transaction itemized below is the one created in the\nSimple Raw Transaction section of the\nDeveloper Examples. It spends a previous pay-to-pubkey output by paying\nto a new pay-to-pubkey-hash (P2PKH) output.  01000000 ................................... Version\n\n01 ......................................... Number of inputs\n|\n| 7b1eabe0209b1fe794124575ef807057\n| c77ada2138ae4fa8d6c4de0398a14f3f ......... Outpoint TXID\n| 00000000 ................................. Outpoint index number\n|\n| 49 ....................................... Bytes in sig. script: 73\n| | 48 ..................................... Push 72 bytes as data\n| | | 30450221008949f0cb400094ad2b5eb3\n| | | 99d59d01c14d73d8fe6e96df1a7150de\n| | | b388ab8935022079656090d7f6bac4c9\n| | | a94e0aad311a4268e082a725f8aeae05\n| | | 73fb12ff866a5f01 ..................... Secp256k1 signature\n|\n| ffffffff ................................. Sequence number: UINT32_MAX\n\n01 ......................................... Number of outputs\n| f0ca052a01000000 ......................... Satoshis (49.99990000 BTC)\n|\n| 19 ....................................... Bytes in pubkey script: 25\n| | 76 ..................................... OP_DUP\n| | a9 ..................................... OP_HASH160\n| | 14 ..................................... Push 20 bytes as data\n| | | cbc20a7664f2f69e5355aa427045bc15\n| | | e7c6c772 ............................. PubKey hash\n| | 88 ..................................... OP_EQUALVERIFY\n| | ac ..................................... OP_CHECKSIG\n\n00000000 ................................... locktime: 0 (a block height)", 
            "title": "TxOut: A Transaction Output {#txout}"
        }, 
        {
            "location": "/transactions/#coinbase-input-the-input-of-the-first-transaction-in-a-block-coinbase", 
            "text": "The first transaction in a block, called the coinbase transaction, must\nhave exactly one input, called a coinbase. The coinbase input currently\nhas the following format.     Bytes  Name  Data Type  Description      32  hash (null)  char[32]  A 32-byte null, as a coinbase has no previous outpoint.    4  index (UINT32_MAX)  uint32_t  0xffffffff, as a coinbase has no previous outpoint.    Varies  script bytes  compactSize uint  The number of bytes in the coinbase script, up to a maximum of 100 bytes.    Varies  (4)  height  script  The block height of this block as required by BIP34.  Uses script language: starts with a data-pushing opcode that indicates how many bytes to push to the stack followed by the block height as a little-endian unsigned integer.  This script must be as short as possible, otherwise it may be rejected.   The data-pushing opcode will be 0x03 and the total size four bytes until block 16,777,216 about 300 years from now.    Varies  coinbase script  None  The coinbase field Arbitrary data not exceeding 100 bytes minus the (4) height bytes.  Miners commonly place an extra nonce in this field to update the block header merkle root during hashing.    4  sequence  uint32_t  Sequence number.     Most (but not all) blocks prior to block height 227,836 used block\nversion 1 which did not require the height parameter to be prefixed to\nthe coinbase script.  The block height parameter is now required.  Although the coinbase script is arbitrary data, if it includes the\nbytes used by any signature-checking operations such as  OP_CHECKSIG ,\nthose signature checks will be counted as signature operations (sigops)\ntowards the block's sigop limit.  To avoid this, you can prefix all data\nwith the appropriate push operation.  An itemized coinbase transaction:  01000000 .............................. Version\n\n01 .................................... Number of inputs\n| 00000000000000000000000000000000\n| 00000000000000000000000000000000 ...  Previous outpoint TXID\n| ffffffff ............................ Previous outpoint index\n|\n| 29 .................................. Bytes in coinbase\n| |\n| | 03 ................................ Bytes in height\n| | | 4e0105 .......................... Height: 328014\n| |\n| | 062f503253482f0472d35454085fffed\n| | f2400000f90f54696d65202620486561\n| | 6c74682021 ........................ Arbitrary data\n| 00000000 ............................ Sequence\n\n01 .................................... Output count\n| 2c37449500000000 .................... Satoshis (25.04275756 BTC)\n| 1976a914a09be8040cbf399926aeb1f4\n| 70c37d1341f3b46588ac ................ P2PKH script\n| 00000000 ............................ Locktime", 
            "title": "Coinbase Input: The Input Of The First Transaction In A Block {#coinbase}"
        }, 
        {
            "location": "/transactions/#compactsize-unsigned-integers", 
            "text": "The raw transaction format and several peer-to-peer network messages use\na type of variable-length integer to indicate the number of bytes in a\nfollowing piece of data.  Bitcoin Core code and this document refers to these variable length\nintegers as compactSize. Many other documents refer to them as var_int\nor varInt, but this risks conflation with other variable-length integer\nencodings---such as the CVarInt class used in Bitcoin Core for\nserializing data to disk.  Because it's used in the transaction format,\nthe format of compactSize unsigned integers is part of the consensus\nrules.  For numbers from 0 to 252, compactSize unsigned integers look like\nregular unsigned integers. For other numbers up to 0xffffffffffffffff, a\nbyte is prefixed to the number to indicate its length---but otherwise\nthe numbers look like regular unsigned integers in little-endian order.     Value  Bytes Used  Format      = 0    = 252  1  uint8_t    = 253    = 0xffff  3  0xfd followed by the number as uint16_t    = 0x10000    = 0xffffffff  5  0xfe followed by the number as uint32_t    = 0x100000000    = 0xffffffffffffffff  9  0xff followed by the number as uint64_t     For example, the number 515 is encoded as 0xfd0302.", 
            "title": "CompactSize Unsigned Integers"
        }, 
        {
            "location": "/p2p/", 
            "text": "This section describes the Pinkcoin P2P network protocol (but it is not a\nspecification).\n\n\nAll peer-to-peer communication occurs entirely over TCP.\n\n\nNote:\n unless their description says otherwise, all multi-byte\nintegers mentioned in this section are transmitted in little-endian order.\n\n\nConstants And Defaults\n\n\n\n\n\n\n\n\nNetwork\n\n\nDefault Port\n\n\nStart String\n\n\nMax nBits\n\n\n\n\n\n\n\n\n\n\nMainnet\n\n\n9134\n\n\nf2f4f9fb\n\n\n-\n\n\n\n\n\n\nTestnet\n\n\n19134\n\n\n0204050d\n\n\n-\n\n\n\n\n\n\n\n\nCommand line parameters can change what port a node listens on (see\n\n-help\n). Start strings are hardcoded constants that appear at the start\nof all messages sent on the Pinkcoin network; they may also appear in\ndata files such as Pinkcoin's block database.  The nBits displayed\nabove are in big-endian order; they're sent over the network in\nlittle-endian order.\n\n\nProtocol Versions\n\n\nThe table below lists some notable versions of the P2P network protocol,\nwith the most recent versions listed first. (If you know of a protocol\nversion that implemented a major change but which is not listed here,\nplease open an issue.)\n\n\nAs of Pinkcoin v2.1.0.4 , the most recent protocol version is 60014.\n\n\n\n\n\n\n\n\nVersion\n\n\nInitial Release\n\n\nMajor Changes\n\n\n\n\n\n\n\n\n\n\n60014\n\n\nPinkcoin v2.1.0.3\n\n\nHardforking Network Attack Bug-fix (\nDetails\n)\n\n\n\n\n\n\n\n\nMessage Headers\n\n\nAll messages in the network protocol use the same container format,\nwhich provides a required multi-field message header and an optional payload.\nThe message header format is:\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\nstart string\n\n\nchar[4]\n\n\nMagic bytes indicating the originating network; used to seek to next message when stream state is unknown.\n\n\n\n\n\n\n12\n\n\ncommand name\n\n\nchar[12]\n\n\nASCII string which identifies what message type is contained in the payload.  Followed by nulls (0x00) to pad out byte count; for example: \nversion\\0\\0\\0\\0\\0\n.\n\n\n\n\n\n\n4\n\n\npayload size\n\n\nuint32_t\n\n\nNumber of bytes in payload.  The current maximum number of bytes (\nMAX_SIZE\n) allowed in the payload by Bitcoin Core is 32 MiB---messages with a payload size larger than this will be dropped or rejected.\n\n\n\n\n\n\n4\n\n\nchecksum\n\n\nchar[4]\n\n\nFirst 4 bytes of SHA256(SHA256(payload)) in internal byte order.\n If payload is empty, as in \nverack\n and \ngetaddr\n messages, the checksum is always 0x5df6e0e2 (SHA256(SHA256(\\\n))).\n\n\n\n\n\n\n\n\nThe following example is an annotated hex dump of a mainnet message\nheader from a \nverack\n message which has no payload.\n\n\nf2f4f9fb ................... Start string: Mainnet\n76657261636b000000000000 ... Command name: verack + null padding\n00000000 ................... Byte count: 0\n5df6e0e2 ................... Checksum: SHA256(SHA256(\nempty\n))\n\n\n\n\nData Messages\n\n\nThe following network messages all request or provide data related to\ntransactions and blocks.\n\n\n\n\nMany of the data messages use\ninventories as unique identifiers\nfor transactions and blocks.  Inventories have a simple 36-byte\nstructure:\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\ntype identifier\n\n\nuint32_t\n\n\nThe type of object which was hashed.  See list of type identifiers below.\n\n\n\n\n\n\n32\n\n\nhash\n\n\nchar[32]\n\n\nSHA256(SHA256()) hash of the object in internal byte order.\n\n\n\n\n\n\n\n\nThe currently-available type identifiers are:\n\n\n\n\n\n\n\n\nType Identifier\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1\n\n\nMSG_TX\n\n\nThe hash is a TXID.\n\n\n\n\n\n\n2\n\n\nMSG_BLOCK\n\n\nThe hash is of a block header.\n\n\n\n\n\n\n\n\nType identifier zero and type identifiers greater than two are reserved\nfor future implementations. Pinkcoin ignores all inventories with\none of these unknown types.\n\n\nBlock\n\n\nThe \nblock\n message transmits a single serialized block in the format\ndescribed in the \nserialized blocks section\n.\nSee that section for an example hexdump.  It can be sent for two\ndifferent reasons:\n\n\n\n\n\n\nGetData Response:\n Nodes will always send it in response to a\n   \ngetdata\n message that requests the block with an inventory\n   type of \nMSG_BLOCK\n (provided the node has that block available for\n   relay).\n\n\n\n\n\n\nUnsolicited:\n Some miners will send unsolicited \nblock\n messages\n   broadcasting their newly-mined blocks to all of their peers. Many\n   mining pools do the same thing, although some may be misconfigured to\n   send the block from multiple nodes, possibly sending the same block\n   to some peers more than once.\n\n\n\n\n\n\nGetBlocks\n\n\nThe \ngetblocks\n message requests an \ninv\n message that provides block\nheader hashes starting from a particular point in the block chain. It\nallows a peer which has been disconnected or started for the first time\nto get the data it needs to request the blocks it hasn't seen.\n\n\nPeers which have been disconnected may have stale blocks in their\nlocally-stored block chain, so the \ngetblocks\n message allows the\nrequesting peer to provide the receiving peer with multiple header\nhashes at various heights on their local chain. This allows the\nreceiving peer to find, within that list, the last header hash they had\nin common and reply with all subsequent header hashes.\n\n\nNote: the receiving peer itself may respond with an \ninv\n message\ncontaining header hashes of stale blocks.  It is up to the requesting\npeer to poll all of its peers to find the best block chain.\n\n\nIf the receiving peer does not find a common header hash within the\nlist, it will assume the last common block was the genesis block (block\nzero), so it will reply with in \ninv\n message containing header hashes\nstarting with block one (the first block after the genesis block).\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\nversion\n\n\nuint32_t\n\n\nThe protocol version number; the same as sent in the \nversion\n message.\n\n\n\n\n\n\nVaries\n\n\nhash count\n\n\ncompactSize uint\n\n\nThe number of header hashes provided not including the stop hash.  There is no limit except that the byte size of the entire message must be below the \nMAX_SIZE\n limit; typically from 1 to 200 hashes are sent.\n\n\n\n\n\n\nVaries\n\n\nblock header hashes\n\n\nchar[32]\n\n\nOne or more block header hashes (32 bytes each) in internal byte order.  Hashes should be provided in reverse order of block height, so highest-height hashes are listed first and lowest-height hashes are listed last.\n\n\n\n\n\n\n32\n\n\nstop hash\n\n\nchar[32]\n\n\nThe header hash of the last header hash being requested; set to all zeroes to request an \ninv\n message with all subsequent header hashes (a maximum of 500 will be sent as a reply to this message; if you need more than 500, you will need to send another \ngetblocks\n message with a higher-height header hash as the first entry in block header hash field).\n\n\n\n\n\n\n\n\nThe following annotated hexdump shows a \ngetblocks\n message.  (The\nmessage header has been omitted.)\n\n\n71110100 ........................... Protocol version: 70001\n02 ................................. Hash count: 2\n\nd39f608a7775b537729884d4e6633bb2\n105e55a16a14d31b0000000000000000 ... Hash #1\n\n5c3e6403d40837110a2e8afb602b1c01\n714bda7ce23bea0a0000000000000000 ... Hash #2\n\n00000000000000000000000000000000\n00000000000000000000000000000000 ... Stop hash\n\n\n\n\nGetData\n\n\nThe \ngetdata\n message requests one or more data objects from another\nnode. The objects are requested by an inventory, which the requesting\nnode typically received previously by way of an \ninv\n message.\n\n\nThe response to a \ngetdata\n message can be a \ntx\n message, \nblock\n\nmessage, \nmerkleblock\n message, or \nnotfound\n message.\n\n\nThis message cannot be used to request arbitrary data, such as historic\ntransactions no longer in the memory pool or relay set. Full nodes may\nnot even be able to provide older blocks if they've pruned old\ntransactions from their block database. For this reason, the \ngetdata\n\nmessage should usually only be used to request data from a node which\npreviously advertised it had that data by sending an \ninv\n message.\n\n\nThe format and maximum size limitations of the \ngetdata\n message are\nidentical to the \ninv\n message; only the message header differs.\n\n\nGetHeaders\n\n\nThe \ngetheaders\n message requests a \nheaders\n message that provides block headers\nstarting from a particular point in the block chain. It allows a\npeer which has been disconnected or started for the first time to get\nthe headers it hasn\u2019t seen yet.\n\n\nThe \ngetheaders\n message is nearly identical to the \ngetblocks\n message,\nwith one minor difference: the \ninv\n reply to the \ngetblocks\n message\nwill include no more than 500 block header hashes; the \nheaders\n reply\nto the \ngetheaders\n message will include as many as 2,000 block headers.\n\n\nHeaders\n\n\nThe \nheaders\n message sends block headers to a node which\npreviously requested certain headers with a \ngetheaders\n message. A headers\nmessage can be empty.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nVaries\n\n\ncount\n\n\ncompactSize uint\n\n\nNumber of block headers up to a maximum of 2,000.  Note: headers-first sync assumes the sending node will send the maximum number of headers whenever possible.\n\n\n\n\n\n\nVaries\n\n\nheaders\n\n\nblock_header\n\n\nBlock headers: each 80-byte block header is in the format described in the \nblock headers section\n with an additional 0x00 suffixed.  This 0x00 is called the transaction count, but because the headers message doesn't include any transactions, the transaction count is always zero.\n\n\n\n\n\n\n\n\nThe following annotated hexdump shows a \nheaders\n message.  (The message\nheader has been omitted.)\n\n\n01 ................................. Header count: 1\n\n02000000 ........................... Block version: 2\nb6ff0b1b1680a2862a30ca44d346d9e8\n910d334beb48ca0c0000000000000000 ... Hash of previous block's header\n9d10aa52ee949386ca9385695f04ede2\n70dda20810decd12bc9b048aaab31471 ... Merkle root\n24d95a54 ........................... Unix time: 1415239972\n30c31b18 ........................... Target (bits)\nfe9f0864 ........................... Nonce\n\n00 ................................. Transaction count (0x00)\n\n\n\n\nInv\n\n\nThe \ninv\n message (inventory message) transmits one or more inventories of\nobjects known to the transmitting peer.  It can be sent unsolicited to\nannounce new transactions or blocks, or it can be sent in reply to a\n\ngetblocks\n message or \nmempool\n message.\n\n\nThe receiving peer can compare the inventories from an \ninv\n message\nagainst the inventories it has already seen, and then use a follow-up\nmessage to request unseen objects.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nVaries\n\n\ncount\n\n\ncompactSize uint\n\n\nThe number of inventory entries.\n\n\n\n\n\n\nVaries\n\n\ninventory\n\n\ninventory\n\n\nOne or more inventory entries up to a maximum of 50,000 entries.\n\n\n\n\n\n\n\n\nThe following annotated hexdump shows an \ninv\n message with two\ninventory entries.  (The message header has been omitted.)\n\n\n02 ................................. Count: 2\n\n01000000 ........................... Type: MSG_TX\nde55ffd709ac1f5dc509a0925d0b1fc4\n42ca034f224732e429081da1b621f55a ... Hash (TXID)\n\n01000000 ........................... Type: MSG_TX\n91d36d997037e08018262978766f24b8\na055aaf1d872e94ae85e9817b2c68dc7 ... Hash (TXID)\n\n\n\n\nMemPool\n\n\nThe \nmempool\n message requests the TXIDs of transactions that the\nreceiving node has verified as valid but which have not yet appeared in\na block. That is, transactions which are in the receiving node's memory\npool. The response to the \nmempool\n message is one or more \ninv\n\nmessages containing the TXIDs in the usual inventory format.\n\n\nSending the \nmempool\n message is mostly useful when a program first\nconnects to the network. Full nodes can use it to quickly gather most or\nall of the unconfirmed transactions available on the network; this is\nespecially useful for miners trying to gather transactions for their\ntransaction fees. SPV clients can set a filter before sending a\n\nmempool\n to only receive transactions that match that filter; this\nallows a recently-started client to get most or all unconfirmed\ntransactions related to its wallet.\n\n\nThe \ninv\n response to the \nmempool\n message is, at best, one node's\nview of the network---not a complete list of unconfirmed transactions\non the network. Here are some additional reasons the list might not\nbe complete:\n\n\n\n\n\n\nBefore Bitcoin Core 0.9.0, the response to the \nmempool\n message was\n  only one \ninv\n message. An \ninv\n message is limited to 50,000\n  inventories, so a node with a memory pool larger than 50,000 entries\n  would not send everything.  Later versions of Bitcoin Core send as\n  many \ninv\n messages as needed to reference its complete memory pool.\n\n\n\n\n\n\nThe \nmempool\n message is not currently fully compatible with the\n  \nfilterload\n message's \nBLOOM_UPDATE_ALL\n and\n  \nBLOOM_UPDATE_P2PUBKEY_ONLY\n flags. Mempool transactions are not\n  sorted like in-block transactions, so a transaction (tx2) spending an\n  output can appear before the transaction (tx1) containing that output,\n  which means the automatic filter update mechanism won't operate until\n  the second-appearing transaction (tx1) is seen---missing the\n  first-appearing transaction (tx2). It has been proposed in [Bitcoin\n  Core issue #2381][] that the transactions should be sorted before\n  being processed by the filter.\n\n\n\n\n\n\nThere is no payload in a \nmempool\n message.  See the [message header\nsection][section message header] for an example of a message without a payload.\n\n\nTx\n\n\nThe \ntx\n message transmits a single transaction in the raw transaction\nformat. It can be sent in a variety of situations;\n\n\n\n\n\n\nTransaction Response:\n Bitcoin Core and BitcoinJ will send it in\n  response to a \ngetdata\n message that requests the transaction with an\n  inventory type of \nMSG_TX\n.\n\n\n\n\n\n\nMerkleBlock Response:\n Bitcoin Core will send it in response to a\n  \ngetdata\n message that requests a merkle block with an inventory type\n  of \nMSG_MERKLEBLOCK\n. (This is in addition to sending a \nmerkleblock\n\n  message.) Each \ntx\n message in this case provides a matched\n  transaction from that block.\n\n\n\n\n\n\nUnsolicited:\n BitcoinJ will send a \ntx\n message unsolicited for\n  transactions it originates.\n\n\n\n\n\n\nFor an example hexdump of the raw transaction format, see the \nraw\ntransaction section\n.\n\n\nControl Messages\n\n\nThe following network messages all help control the connection between\ntwo peers or allow them to advise each other about the rest of the\nnetwork.\n\n\n\n\nNote that almost none of the control messages are authenticated in any\nway, meaning they can contain incorrect or intentionally harmful\ninformation. In addition, this section does not yet cover P2P protocol\noperation over the Tor network; if you would like to contribute\ninformation about Tor, please open an issue.\n\n\nAddr\n\n\nThe \naddr\n (IP address) message relays connection information\nfor peers on the network. Each peer which wants to accept incoming\nconnections creates an \naddr\n message providing its connection\ninformation and then sends that message to its peers unsolicited. Some\nof its peers send that information to their peers (also unsolicited),\nsome of which further distribute it, allowing decentralized peer\ndiscovery for any program already on the network.\n\n\nAn \naddr\n message may also be sent in response to a \ngetaddr\n message.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nVaries\n\n\nIP address count\n\n\ncompactSize uint\n\n\nThe number of IP address entries up to a maximum of 1,000.\n\n\n\n\n\n\nVaries\n\n\nIP addresses\n\n\nnetwork IP address\n\n\nIP address entries.  See the table below for the format of a Bitcoin network IP address.\n\n\n\n\n\n\n\n\nEach encapsulated network IP address currently uses the following structure:\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\ntime\n\n\nuint32\n\n\nAdded in protocol version 31402.\n \nA time in Unix epoch time format.  Nodes advertising their own IP address set this to the current time.  Nodes advertising IP addresses they've connected to set this to the last time they connected to that node.  Other nodes just relaying the IP address should not change the time.  Nodes can use the time field to avoid relaying old \naddr\n messages.  \nMalicious nodes may change times or even set them in the future.\n\n\n\n\n\n\n8\n\n\nservices\n\n\nuint64_t\n\n\nThe services the node advertised in its \nversion\n message.\n\n\n\n\n\n\n16\n\n\nIP address\n\n\nchar\n\n\nIPv6 address in \nbig endian byte order\n. IPv4 addresses can be provided as IPv4-mapped IPv6 addresses\n\n\n\n\n\n\n2\n\n\nport\n\n\nuint16_t\n\n\nPort number in \nbig endian byte order\n.  Note that Bitcoin Core will only connect to nodes with non-standard port numbers as a last resort for finding peers.  This is to prevent anyone from trying to use the network to disrupt non-Bitcoin services that run on other ports.\n\n\n\n\n\n\n\n\nThe following annotated hexdump shows part of an \naddr\n message. (The\nmessage header has been omitted and the actual IP address has been\nreplaced with a RFC5737 reserved IP address.)\n\n\nfde803 ............................. Address count: 1000\n\nd91f4854 ........................... Epoch time: 1414012889\n0100000000000000 ................... Service bits: 01 (network node)\n00000000000000000000ffffc0000233 ... IP Address: ::ffff:192.0.2.51\n208d ............................... Port: 8333\n\n[...] .............................. (999 more addresses omitted)\n\n\n\n\nGetAddr\n\n\nThe \ngetaddr\n message requests an \naddr\n message from the receiving\nnode, preferably one with lots of IP addresses of other receiving nodes.\nThe transmitting node can use those IP addresses to quickly update its\ndatabase of available nodes rather than waiting for unsolicited \naddr\n\nmessages to arrive over time.\n\n\nThere is no payload in a \ngetaddr\n message.  See the [message header\nsection][section message header] for an example of a message without a payload.\n\n\nPing\n\n\nThe \nping\n message helps confirm that the receiving peer is still\nconnected. If a TCP/IP error is encountered when sending the \nping\n\nmessage (such as a connection timeout), the transmitting node can assume\nthat the receiving node is disconnected. The response to a \nping\n\nmessage is the \npong\n message.\n\n\nBefore protocol version 60000, the \nping\n message had no payload. As of\nprotocol version 60001 and all later versions, the message includes a\nsingle field, the nonce.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n8\n\n\nnonce\n\n\nuint64_t\n\n\nAdded in protocol version 60001 as described by BIP31.\n \nRandom nonce assigned to this \nping\n message.  The responding \npong\n message will include this nonce to identify the \nping\n message to which it is replying.\n\n\n\n\n\n\n\n\nThe annotated hexdump below shows a \nping\n message. (The message\nheader has been omitted.)\n\n\n0094102111e2af4d ... Nonce\n\n\n\n\nPong\n\n\nAdded in protocol version 60001 as described by BIP31.\n\n\nThe \npong\n message replies to a \nping\n message, proving to the pinging\nnode that the ponging node is still alive. Bitcoin Core will, by\ndefault, disconnect from any clients which have not responded to a\n\nping\n message within 20 minutes.\n\n\nTo allow nodes to keep track of latency, the \npong\n message sends back\nthe same nonce received in the \nping\n message it is replying to.\n\n\nThe format of the \npong\n message is identical to the \nping\n message;\nonly the message header differs.\n\n\nVerAck\n\n\nAdded in protocol version 209.\n\n\nThe \nverack\n message acknowledges a previously-received \nversion\n\nmessage, informing the connecting node that it can begin to send\nother messages. The \nverack\n message has no payload; for an example\nof a message with no payload, see the [message headers\nsection][section message header].\n\n\nVersion\n\n\nThe \nversion\n message provides information about the transmitting node\nto the receiving node at the beginning of a connection. Until both peers\nhave exchanged \nversion\n messages, no other messages will be accepted.\n\n\nIf a \nversion\n message is accepted, the receiving node should send a\n\nverack\n message---but no node should send a \nverack\n message\nbefore initializing its half of the connection by first sending a\n\nversion\n message.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nRequired/Optional\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\nversion\n\n\nint32_t\n\n\nRequired\n\n\nThe highest protocol version understood by the transmitting node.  See the [protocol version section][section protocol versions].\n\n\n\n\n\n\n8\n\n\nservices\n\n\nuint64_t\n\n\nRequired\n\n\nThe services supported by the transmitting node encoded as a bitfield.  See the list of service codes below.\n\n\n\n\n\n\n8\n\n\ntimestamp\n\n\nint64_t\n\n\nRequired\n\n\nThe current Unix epoch time according to the transmitting node's clock.  Because nodes will reject blocks with timestamps more than two hours in the future, this field can help other nodes to determine that their clock is wrong.\n\n\n\n\n\n\n8\n\n\naddr_recv services\n\n\nuint64_t\n\n\nRequired\n\n\nThe services supported by the receiving node as perceived by the transmitting node.  Same format as the 'services' field above. Bitcoin Core will attempt to provide accurate information.  BitcoinJ will, by default, always send 0.\n\n\n\n\n\n\n16\n\n\naddr_recv IP address\n\n\nchar\n\n\nRequired\n\n\nThe IPv6 address of the receiving node as perceived by the transmitting node in \nbig endian byte order\n. IPv4 addresses can be provided as [IPv4-mapped IPv6 addresses][]. Bitcoin Core will attempt to provide accurate information.  BitcoinJ will, by default, always return ::ffff:127.0.0.1\n\n\n\n\n\n\n2\n\n\naddr_recv port\n\n\nuint16_t\n\n\nRequired\n\n\nThe port number of the receiving node as perceived by the transmitting node in \nbig endian byte order\n.\n\n\n\n\n\n\n8\n\n\naddr_trans services\n\n\nuint64_t\n\n\nRequired\n\n\nAdded in protocol version 106.\n \nThe services supported by the transmitting node.  Should be identical to the 'services' field above.\n\n\n\n\n\n\n16\n\n\naddr_trans IP address\n\n\nchar\n\n\nRequired\n\n\nAdded in protocol version 106.\n \nThe IPv6 address of the transmitting node in \nbig endian byte order\n. IPv4 addresses can be provided as [IPv4-mapped IPv6 addresses][].  Set to ::ffff:127.0.0.1 if unknown.\n\n\n\n\n\n\n2\n\n\naddr_trans port\n\n\nuint16_t\n\n\nRequired\n\n\nAdded in protocol version 106.\n \nThe port number of the transmitting node in \nbig endian byte order\n.\n\n\n\n\n\n\n8\n\n\nnonce\n\n\nuint64_t\n\n\nRequired\n\n\nAdded in protocol version 106.\n \nA random nonce which can help a node detect a connection to itself.  If the nonce is 0, the nonce field is ignored.  If the nonce is anything else, a node should terminate the connection on receipt\n of a \nversion\n message with a nonce it previously sent.\n\n\n\n\n\n\nVaries\n\n\nuser_agent bytes\n\n\ncompactSize uint\n\n\nRequired\n\n\nAdded in protocol version 106.\n \nNumber of bytes in following user_agent field.  If 0x00, no user agent field is sent.\n\n\n\n\n\n\nVaries\n\n\nuser_agent\n\n\nstring\n\n\nRequired if user_agent bytes \n 0\n\n\nAdded in protocol version 106. Renamed in protocol version 60000.\n \nUser agent as defined by BIP14. Previously called subVer.\n\n\n\n\n\n\n4\n\n\nstart_height\n\n\nint32_t\n\n\nRequired\n\n\nAdded in protocol version 209.\n \nThe height of the transmitting node's best block chain or, in the case of an SPV client, best block header chain.\n\n\n\n\n\n\n1\n\n\nrelay\n\n\nbool\n\n\nOptional\n\n\nAdded in protocol version 70001 as described by BIP37.\n \nTransaction relay flag.  If 0x00, no \ninv\n messages or \ntx\n messages announcing new transactions should be sent to this client until it sends a \nfilterload\n message or \nfilterclear\n message.  If the relay field is not present or is set to 0x01, this node wants \ninv\n messages and \ntx\n messages announcing new transactions.\n\n\n\n\n\n\n\n\nThe following service identifiers have been assigned.\n\n\n\n\n\n\n\n\nValue\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0x00\n\n\nUnnamed\n\n\nThis node is not a full node.  It may not be able to provide any data except for the transactions it originates.\n\n\n\n\n\n\n0x01\n\n\nNODE_NETWORK\n\n\nThis is a full node and can be asked for full blocks.  It should implement all protocol features available in its self-reported protocol version.\n\n\n\n\n\n\n\n\nThe following annotated hexdump shows a \nversion\n message. (The\nmessage header has been omitted and the actual IP addresses have been\nreplaced with [RFC5737][] reserved IP addresses.)\n\n\n72110100 ........................... Protocol version: 70002\n0100000000000000 ................... Services: NODE_NETWORK\nbc8f5e5400000000 ................... Epoch time: 1415483324\n\n0100000000000000 ................... Receiving node's services\n00000000000000000000ffffc61b6409 ... Receiving node's IPv6 address\n208d ............................... Receiving node's port number\n\n0100000000000000 ................... Transmitting node's services\n00000000000000000000ffffcb0071c0 ... Transmitting node's IPv6 address\n208d ............................... Transmitting node's port number\n\n128035cbc97953f8 ................... Nonce\n\n0f ................................. Bytes in user agent string: 15\n2f5361746f7368693a302e392e332f ..... User agent: /Satoshi:0.9.3/\n\ncf050500 ........................... Start height: 329167\n01 ................................. Relay flag: true", 
            "title": "P2P Network"
        }, 
        {
            "location": "/p2p/#constants-and-defaults", 
            "text": "Network  Default Port  Start String  Max nBits      Mainnet  9134  f2f4f9fb  -    Testnet  19134  0204050d  -     Command line parameters can change what port a node listens on (see -help ). Start strings are hardcoded constants that appear at the start\nof all messages sent on the Pinkcoin network; they may also appear in\ndata files such as Pinkcoin's block database.  The nBits displayed\nabove are in big-endian order; they're sent over the network in\nlittle-endian order.", 
            "title": "Constants And Defaults"
        }, 
        {
            "location": "/p2p/#protocol-versions", 
            "text": "The table below lists some notable versions of the P2P network protocol,\nwith the most recent versions listed first. (If you know of a protocol\nversion that implemented a major change but which is not listed here,\nplease open an issue.)  As of Pinkcoin v2.1.0.4 , the most recent protocol version is 60014.     Version  Initial Release  Major Changes      60014  Pinkcoin v2.1.0.3  Hardforking Network Attack Bug-fix ( Details )", 
            "title": "Protocol Versions"
        }, 
        {
            "location": "/p2p/#message-headers", 
            "text": "All messages in the network protocol use the same container format,\nwhich provides a required multi-field message header and an optional payload.\nThe message header format is:     Bytes  Name  Data Type  Description      4  start string  char[4]  Magic bytes indicating the originating network; used to seek to next message when stream state is unknown.    12  command name  char[12]  ASCII string which identifies what message type is contained in the payload.  Followed by nulls (0x00) to pad out byte count; for example:  version\\0\\0\\0\\0\\0 .    4  payload size  uint32_t  Number of bytes in payload.  The current maximum number of bytes ( MAX_SIZE ) allowed in the payload by Bitcoin Core is 32 MiB---messages with a payload size larger than this will be dropped or rejected.    4  checksum  char[4]  First 4 bytes of SHA256(SHA256(payload)) in internal byte order.  If payload is empty, as in  verack  and  getaddr  messages, the checksum is always 0x5df6e0e2 (SHA256(SHA256(\\ ))).     The following example is an annotated hex dump of a mainnet message\nheader from a  verack  message which has no payload.  f2f4f9fb ................... Start string: Mainnet\n76657261636b000000000000 ... Command name: verack + null padding\n00000000 ................... Byte count: 0\n5df6e0e2 ................... Checksum: SHA256(SHA256( empty ))", 
            "title": "Message Headers"
        }, 
        {
            "location": "/p2p/#data-messages", 
            "text": "The following network messages all request or provide data related to\ntransactions and blocks.   Many of the data messages use\ninventories as unique identifiers\nfor transactions and blocks.  Inventories have a simple 36-byte\nstructure:     Bytes  Name  Data Type  Description      4  type identifier  uint32_t  The type of object which was hashed.  See list of type identifiers below.    32  hash  char[32]  SHA256(SHA256()) hash of the object in internal byte order.     The currently-available type identifiers are:     Type Identifier  Name  Description      1  MSG_TX  The hash is a TXID.    2  MSG_BLOCK  The hash is of a block header.     Type identifier zero and type identifiers greater than two are reserved\nfor future implementations. Pinkcoin ignores all inventories with\none of these unknown types.", 
            "title": "Data Messages"
        }, 
        {
            "location": "/p2p/#block", 
            "text": "The  block  message transmits a single serialized block in the format\ndescribed in the  serialized blocks section .\nSee that section for an example hexdump.  It can be sent for two\ndifferent reasons:    GetData Response:  Nodes will always send it in response to a\n    getdata  message that requests the block with an inventory\n   type of  MSG_BLOCK  (provided the node has that block available for\n   relay).    Unsolicited:  Some miners will send unsolicited  block  messages\n   broadcasting their newly-mined blocks to all of their peers. Many\n   mining pools do the same thing, although some may be misconfigured to\n   send the block from multiple nodes, possibly sending the same block\n   to some peers more than once.", 
            "title": "Block"
        }, 
        {
            "location": "/p2p/#getblocks", 
            "text": "The  getblocks  message requests an  inv  message that provides block\nheader hashes starting from a particular point in the block chain. It\nallows a peer which has been disconnected or started for the first time\nto get the data it needs to request the blocks it hasn't seen.  Peers which have been disconnected may have stale blocks in their\nlocally-stored block chain, so the  getblocks  message allows the\nrequesting peer to provide the receiving peer with multiple header\nhashes at various heights on their local chain. This allows the\nreceiving peer to find, within that list, the last header hash they had\nin common and reply with all subsequent header hashes.  Note: the receiving peer itself may respond with an  inv  message\ncontaining header hashes of stale blocks.  It is up to the requesting\npeer to poll all of its peers to find the best block chain.  If the receiving peer does not find a common header hash within the\nlist, it will assume the last common block was the genesis block (block\nzero), so it will reply with in  inv  message containing header hashes\nstarting with block one (the first block after the genesis block).     Bytes  Name  Data Type  Description      4  version  uint32_t  The protocol version number; the same as sent in the  version  message.    Varies  hash count  compactSize uint  The number of header hashes provided not including the stop hash.  There is no limit except that the byte size of the entire message must be below the  MAX_SIZE  limit; typically from 1 to 200 hashes are sent.    Varies  block header hashes  char[32]  One or more block header hashes (32 bytes each) in internal byte order.  Hashes should be provided in reverse order of block height, so highest-height hashes are listed first and lowest-height hashes are listed last.    32  stop hash  char[32]  The header hash of the last header hash being requested; set to all zeroes to request an  inv  message with all subsequent header hashes (a maximum of 500 will be sent as a reply to this message; if you need more than 500, you will need to send another  getblocks  message with a higher-height header hash as the first entry in block header hash field).     The following annotated hexdump shows a  getblocks  message.  (The\nmessage header has been omitted.)  71110100 ........................... Protocol version: 70001\n02 ................................. Hash count: 2\n\nd39f608a7775b537729884d4e6633bb2\n105e55a16a14d31b0000000000000000 ... Hash #1\n\n5c3e6403d40837110a2e8afb602b1c01\n714bda7ce23bea0a0000000000000000 ... Hash #2\n\n00000000000000000000000000000000\n00000000000000000000000000000000 ... Stop hash", 
            "title": "GetBlocks"
        }, 
        {
            "location": "/p2p/#getdata", 
            "text": "The  getdata  message requests one or more data objects from another\nnode. The objects are requested by an inventory, which the requesting\nnode typically received previously by way of an  inv  message.  The response to a  getdata  message can be a  tx  message,  block \nmessage,  merkleblock  message, or  notfound  message.  This message cannot be used to request arbitrary data, such as historic\ntransactions no longer in the memory pool or relay set. Full nodes may\nnot even be able to provide older blocks if they've pruned old\ntransactions from their block database. For this reason, the  getdata \nmessage should usually only be used to request data from a node which\npreviously advertised it had that data by sending an  inv  message.  The format and maximum size limitations of the  getdata  message are\nidentical to the  inv  message; only the message header differs.", 
            "title": "GetData"
        }, 
        {
            "location": "/p2p/#getheaders", 
            "text": "The  getheaders  message requests a  headers  message that provides block headers\nstarting from a particular point in the block chain. It allows a\npeer which has been disconnected or started for the first time to get\nthe headers it hasn\u2019t seen yet.  The  getheaders  message is nearly identical to the  getblocks  message,\nwith one minor difference: the  inv  reply to the  getblocks  message\nwill include no more than 500 block header hashes; the  headers  reply\nto the  getheaders  message will include as many as 2,000 block headers.", 
            "title": "GetHeaders"
        }, 
        {
            "location": "/p2p/#headers", 
            "text": "The  headers  message sends block headers to a node which\npreviously requested certain headers with a  getheaders  message. A headers\nmessage can be empty.     Bytes  Name  Data Type  Description      Varies  count  compactSize uint  Number of block headers up to a maximum of 2,000.  Note: headers-first sync assumes the sending node will send the maximum number of headers whenever possible.    Varies  headers  block_header  Block headers: each 80-byte block header is in the format described in the  block headers section  with an additional 0x00 suffixed.  This 0x00 is called the transaction count, but because the headers message doesn't include any transactions, the transaction count is always zero.     The following annotated hexdump shows a  headers  message.  (The message\nheader has been omitted.)  01 ................................. Header count: 1\n\n02000000 ........................... Block version: 2\nb6ff0b1b1680a2862a30ca44d346d9e8\n910d334beb48ca0c0000000000000000 ... Hash of previous block's header\n9d10aa52ee949386ca9385695f04ede2\n70dda20810decd12bc9b048aaab31471 ... Merkle root\n24d95a54 ........................... Unix time: 1415239972\n30c31b18 ........................... Target (bits)\nfe9f0864 ........................... Nonce\n\n00 ................................. Transaction count (0x00)", 
            "title": "Headers"
        }, 
        {
            "location": "/p2p/#inv", 
            "text": "The  inv  message (inventory message) transmits one or more inventories of\nobjects known to the transmitting peer.  It can be sent unsolicited to\nannounce new transactions or blocks, or it can be sent in reply to a getblocks  message or  mempool  message.  The receiving peer can compare the inventories from an  inv  message\nagainst the inventories it has already seen, and then use a follow-up\nmessage to request unseen objects.     Bytes  Name  Data Type  Description      Varies  count  compactSize uint  The number of inventory entries.    Varies  inventory  inventory  One or more inventory entries up to a maximum of 50,000 entries.     The following annotated hexdump shows an  inv  message with two\ninventory entries.  (The message header has been omitted.)  02 ................................. Count: 2\n\n01000000 ........................... Type: MSG_TX\nde55ffd709ac1f5dc509a0925d0b1fc4\n42ca034f224732e429081da1b621f55a ... Hash (TXID)\n\n01000000 ........................... Type: MSG_TX\n91d36d997037e08018262978766f24b8\na055aaf1d872e94ae85e9817b2c68dc7 ... Hash (TXID)", 
            "title": "Inv"
        }, 
        {
            "location": "/p2p/#mempool", 
            "text": "The  mempool  message requests the TXIDs of transactions that the\nreceiving node has verified as valid but which have not yet appeared in\na block. That is, transactions which are in the receiving node's memory\npool. The response to the  mempool  message is one or more  inv \nmessages containing the TXIDs in the usual inventory format.  Sending the  mempool  message is mostly useful when a program first\nconnects to the network. Full nodes can use it to quickly gather most or\nall of the unconfirmed transactions available on the network; this is\nespecially useful for miners trying to gather transactions for their\ntransaction fees. SPV clients can set a filter before sending a mempool  to only receive transactions that match that filter; this\nallows a recently-started client to get most or all unconfirmed\ntransactions related to its wallet.  The  inv  response to the  mempool  message is, at best, one node's\nview of the network---not a complete list of unconfirmed transactions\non the network. Here are some additional reasons the list might not\nbe complete:    Before Bitcoin Core 0.9.0, the response to the  mempool  message was\n  only one  inv  message. An  inv  message is limited to 50,000\n  inventories, so a node with a memory pool larger than 50,000 entries\n  would not send everything.  Later versions of Bitcoin Core send as\n  many  inv  messages as needed to reference its complete memory pool.    The  mempool  message is not currently fully compatible with the\n   filterload  message's  BLOOM_UPDATE_ALL  and\n   BLOOM_UPDATE_P2PUBKEY_ONLY  flags. Mempool transactions are not\n  sorted like in-block transactions, so a transaction (tx2) spending an\n  output can appear before the transaction (tx1) containing that output,\n  which means the automatic filter update mechanism won't operate until\n  the second-appearing transaction (tx1) is seen---missing the\n  first-appearing transaction (tx2). It has been proposed in [Bitcoin\n  Core issue #2381][] that the transactions should be sorted before\n  being processed by the filter.    There is no payload in a  mempool  message.  See the [message header\nsection][section message header] for an example of a message without a payload.", 
            "title": "MemPool"
        }, 
        {
            "location": "/p2p/#tx", 
            "text": "The  tx  message transmits a single transaction in the raw transaction\nformat. It can be sent in a variety of situations;    Transaction Response:  Bitcoin Core and BitcoinJ will send it in\n  response to a  getdata  message that requests the transaction with an\n  inventory type of  MSG_TX .    MerkleBlock Response:  Bitcoin Core will send it in response to a\n   getdata  message that requests a merkle block with an inventory type\n  of  MSG_MERKLEBLOCK . (This is in addition to sending a  merkleblock \n  message.) Each  tx  message in this case provides a matched\n  transaction from that block.    Unsolicited:  BitcoinJ will send a  tx  message unsolicited for\n  transactions it originates.    For an example hexdump of the raw transaction format, see the  raw\ntransaction section .", 
            "title": "Tx"
        }, 
        {
            "location": "/p2p/#control-messages", 
            "text": "The following network messages all help control the connection between\ntwo peers or allow them to advise each other about the rest of the\nnetwork.   Note that almost none of the control messages are authenticated in any\nway, meaning they can contain incorrect or intentionally harmful\ninformation. In addition, this section does not yet cover P2P protocol\noperation over the Tor network; if you would like to contribute\ninformation about Tor, please open an issue.", 
            "title": "Control Messages"
        }, 
        {
            "location": "/p2p/#addr", 
            "text": "The  addr  (IP address) message relays connection information\nfor peers on the network. Each peer which wants to accept incoming\nconnections creates an  addr  message providing its connection\ninformation and then sends that message to its peers unsolicited. Some\nof its peers send that information to their peers (also unsolicited),\nsome of which further distribute it, allowing decentralized peer\ndiscovery for any program already on the network.  An  addr  message may also be sent in response to a  getaddr  message.     Bytes  Name  Data Type  Description      Varies  IP address count  compactSize uint  The number of IP address entries up to a maximum of 1,000.    Varies  IP addresses  network IP address  IP address entries.  See the table below for the format of a Bitcoin network IP address.     Each encapsulated network IP address currently uses the following structure:     Bytes  Name  Data Type  Description      4  time  uint32  Added in protocol version 31402.   A time in Unix epoch time format.  Nodes advertising their own IP address set this to the current time.  Nodes advertising IP addresses they've connected to set this to the last time they connected to that node.  Other nodes just relaying the IP address should not change the time.  Nodes can use the time field to avoid relaying old  addr  messages.   Malicious nodes may change times or even set them in the future.    8  services  uint64_t  The services the node advertised in its  version  message.    16  IP address  char  IPv6 address in  big endian byte order . IPv4 addresses can be provided as IPv4-mapped IPv6 addresses    2  port  uint16_t  Port number in  big endian byte order .  Note that Bitcoin Core will only connect to nodes with non-standard port numbers as a last resort for finding peers.  This is to prevent anyone from trying to use the network to disrupt non-Bitcoin services that run on other ports.     The following annotated hexdump shows part of an  addr  message. (The\nmessage header has been omitted and the actual IP address has been\nreplaced with a RFC5737 reserved IP address.)  fde803 ............................. Address count: 1000\n\nd91f4854 ........................... Epoch time: 1414012889\n0100000000000000 ................... Service bits: 01 (network node)\n00000000000000000000ffffc0000233 ... IP Address: ::ffff:192.0.2.51\n208d ............................... Port: 8333\n\n[...] .............................. (999 more addresses omitted)", 
            "title": "Addr"
        }, 
        {
            "location": "/p2p/#getaddr", 
            "text": "The  getaddr  message requests an  addr  message from the receiving\nnode, preferably one with lots of IP addresses of other receiving nodes.\nThe transmitting node can use those IP addresses to quickly update its\ndatabase of available nodes rather than waiting for unsolicited  addr \nmessages to arrive over time.  There is no payload in a  getaddr  message.  See the [message header\nsection][section message header] for an example of a message without a payload.", 
            "title": "GetAddr"
        }, 
        {
            "location": "/p2p/#ping", 
            "text": "The  ping  message helps confirm that the receiving peer is still\nconnected. If a TCP/IP error is encountered when sending the  ping \nmessage (such as a connection timeout), the transmitting node can assume\nthat the receiving node is disconnected. The response to a  ping \nmessage is the  pong  message.  Before protocol version 60000, the  ping  message had no payload. As of\nprotocol version 60001 and all later versions, the message includes a\nsingle field, the nonce.     Bytes  Name  Data Type  Description      8  nonce  uint64_t  Added in protocol version 60001 as described by BIP31.   Random nonce assigned to this  ping  message.  The responding  pong  message will include this nonce to identify the  ping  message to which it is replying.     The annotated hexdump below shows a  ping  message. (The message\nheader has been omitted.)  0094102111e2af4d ... Nonce", 
            "title": "Ping"
        }, 
        {
            "location": "/p2p/#pong", 
            "text": "Added in protocol version 60001 as described by BIP31.  The  pong  message replies to a  ping  message, proving to the pinging\nnode that the ponging node is still alive. Bitcoin Core will, by\ndefault, disconnect from any clients which have not responded to a ping  message within 20 minutes.  To allow nodes to keep track of latency, the  pong  message sends back\nthe same nonce received in the  ping  message it is replying to.  The format of the  pong  message is identical to the  ping  message;\nonly the message header differs.", 
            "title": "Pong"
        }, 
        {
            "location": "/p2p/#verack", 
            "text": "Added in protocol version 209.  The  verack  message acknowledges a previously-received  version \nmessage, informing the connecting node that it can begin to send\nother messages. The  verack  message has no payload; for an example\nof a message with no payload, see the [message headers\nsection][section message header].", 
            "title": "VerAck"
        }, 
        {
            "location": "/p2p/#version", 
            "text": "The  version  message provides information about the transmitting node\nto the receiving node at the beginning of a connection. Until both peers\nhave exchanged  version  messages, no other messages will be accepted.  If a  version  message is accepted, the receiving node should send a verack  message---but no node should send a  verack  message\nbefore initializing its half of the connection by first sending a version  message.     Bytes  Name  Data Type  Required/Optional  Description      4  version  int32_t  Required  The highest protocol version understood by the transmitting node.  See the [protocol version section][section protocol versions].    8  services  uint64_t  Required  The services supported by the transmitting node encoded as a bitfield.  See the list of service codes below.    8  timestamp  int64_t  Required  The current Unix epoch time according to the transmitting node's clock.  Because nodes will reject blocks with timestamps more than two hours in the future, this field can help other nodes to determine that their clock is wrong.    8  addr_recv services  uint64_t  Required  The services supported by the receiving node as perceived by the transmitting node.  Same format as the 'services' field above. Bitcoin Core will attempt to provide accurate information.  BitcoinJ will, by default, always send 0.    16  addr_recv IP address  char  Required  The IPv6 address of the receiving node as perceived by the transmitting node in  big endian byte order . IPv4 addresses can be provided as [IPv4-mapped IPv6 addresses][]. Bitcoin Core will attempt to provide accurate information.  BitcoinJ will, by default, always return ::ffff:127.0.0.1    2  addr_recv port  uint16_t  Required  The port number of the receiving node as perceived by the transmitting node in  big endian byte order .    8  addr_trans services  uint64_t  Required  Added in protocol version 106.   The services supported by the transmitting node.  Should be identical to the 'services' field above.    16  addr_trans IP address  char  Required  Added in protocol version 106.   The IPv6 address of the transmitting node in  big endian byte order . IPv4 addresses can be provided as [IPv4-mapped IPv6 addresses][].  Set to ::ffff:127.0.0.1 if unknown.    2  addr_trans port  uint16_t  Required  Added in protocol version 106.   The port number of the transmitting node in  big endian byte order .    8  nonce  uint64_t  Required  Added in protocol version 106.   A random nonce which can help a node detect a connection to itself.  If the nonce is 0, the nonce field is ignored.  If the nonce is anything else, a node should terminate the connection on receipt  of a  version  message with a nonce it previously sent.    Varies  user_agent bytes  compactSize uint  Required  Added in protocol version 106.   Number of bytes in following user_agent field.  If 0x00, no user agent field is sent.    Varies  user_agent  string  Required if user_agent bytes   0  Added in protocol version 106. Renamed in protocol version 60000.   User agent as defined by BIP14. Previously called subVer.    4  start_height  int32_t  Required  Added in protocol version 209.   The height of the transmitting node's best block chain or, in the case of an SPV client, best block header chain.    1  relay  bool  Optional  Added in protocol version 70001 as described by BIP37.   Transaction relay flag.  If 0x00, no  inv  messages or  tx  messages announcing new transactions should be sent to this client until it sends a  filterload  message or  filterclear  message.  If the relay field is not present or is set to 0x01, this node wants  inv  messages and  tx  messages announcing new transactions.     The following service identifiers have been assigned.     Value  Name  Description      0x00  Unnamed  This node is not a full node.  It may not be able to provide any data except for the transactions it originates.    0x01  NODE_NETWORK  This is a full node and can be asked for full blocks.  It should implement all protocol features available in its self-reported protocol version.     The following annotated hexdump shows a  version  message. (The\nmessage header has been omitted and the actual IP addresses have been\nreplaced with [RFC5737][] reserved IP addresses.)  72110100 ........................... Protocol version: 70002\n0100000000000000 ................... Services: NODE_NETWORK\nbc8f5e5400000000 ................... Epoch time: 1415483324\n\n0100000000000000 ................... Receiving node's services\n00000000000000000000ffffc61b6409 ... Receiving node's IPv6 address\n208d ............................... Receiving node's port number\n\n0100000000000000 ................... Transmitting node's services\n00000000000000000000ffffcb0071c0 ... Transmitting node's IPv6 address\n208d ............................... Transmitting node's port number\n\n128035cbc97953f8 ................... Nonce\n\n0f ................................. Bytes in user agent string: 15\n2f5361746f7368693a302e392e332f ..... User agent: /Satoshi:0.9.3/\n\ncf050500 ........................... Start height: 329167\n01 ................................. Relay flag: true", 
            "title": "Version"
        }, 
        {
            "location": "/api/", 
            "text": "", 
            "title": "Pinkcoin API"
        }
    ]
}