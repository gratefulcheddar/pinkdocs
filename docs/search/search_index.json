{
    "docs": [
        {
            "location": "/", 
            "text": "Pinkcoin Developer Documentation\n\n\nFind Technical Details and API Documentation\n\n\nWelcome to the Pinkcoin developer reference. Due to the similarities \nbetween Bitcoin and Pinkcoin, many parts of this reference were borrowed, \nword for word, from the \nBitcoin Developer Reference\n. \nThis reference aims to provide technical details and API information to \nhelp you start building Pinkcoin-based applications, but it is not a \nspecification.\n\n\nQuestions about Pinkcoin development are best asked in the \n\nPinkcoin Discord\n. Errors or \nsuggestions related to this documentation can be \nsubmitted as an issue\n.\n\n\nNot a Specification\n\n\nThis documentation describes how Pinkcoin works to help educate new \nPinkcoin developers, but it is not a specification - and it never will be.\n\n\nPinkcoin security depends on consensus. Should your program diverge from \nconsensus, its security is weakened or destroyed. The cause of the \ndivergence doesn't matter: it could be a bug in your program, it could be \nan error in this documentation which you implemented as described, or it \ncould be you do everything right but other software on the network behaves \nunexpectedly. The specific cause will not matter to the users of your \nsoftware whose wealth is lost.\n\n\nThe only correct specification of consensus behavior is the actual \nbehavior of the programs on the network which maintain consensus. As that \nbehavior is subject to arbitrary inputs in a large variety of unique \nenvironments, it cannot ever be fully documented here or anywhere else.\n\n\nFurthermore, the documentation has not been extensively reviews by \nPinkcoin experts and so likely contains numerous errors. Please use the \nIssue link on the bottom left menu to help us improve.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#pinkcoin-developer-documentation", 
            "text": "", 
            "title": "Pinkcoin Developer Documentation"
        }, 
        {
            "location": "/#find-technical-details-and-api-documentation", 
            "text": "Welcome to the Pinkcoin developer reference. Due to the similarities \nbetween Bitcoin and Pinkcoin, many parts of this reference were borrowed, \nword for word, from the  Bitcoin Developer Reference . \nThis reference aims to provide technical details and API information to \nhelp you start building Pinkcoin-based applications, but it is not a \nspecification.  Questions about Pinkcoin development are best asked in the  Pinkcoin Discord . Errors or \nsuggestions related to this documentation can be  submitted as an issue .", 
            "title": "Find Technical Details and API Documentation"
        }, 
        {
            "location": "/#not-a-specification", 
            "text": "This documentation describes how Pinkcoin works to help educate new \nPinkcoin developers, but it is not a specification - and it never will be.  Pinkcoin security depends on consensus. Should your program diverge from \nconsensus, its security is weakened or destroyed. The cause of the \ndivergence doesn't matter: it could be a bug in your program, it could be \nan error in this documentation which you implemented as described, or it \ncould be you do everything right but other software on the network behaves \nunexpectedly. The specific cause will not matter to the users of your \nsoftware whose wealth is lost.  The only correct specification of consensus behavior is the actual \nbehavior of the programs on the network which maintain consensus. As that \nbehavior is subject to arbitrary inputs in a large variety of unique \nenvironments, it cannot ever be fully documented here or anywhere else.  Furthermore, the documentation has not been extensively reviews by \nPinkcoin experts and so likely contains numerous errors. Please use the \nIssue link on the bottom left menu to help us improve.", 
            "title": "Not a Specification"
        }, 
        {
            "location": "/block-chain/", 
            "text": "Block Headers\n\n\nBlock headers are serialized in the 80-byte format described below and then\nhashed as part of Pinkcoin's proof-of-work algorithm, making the\nserialized header format part of the consensus rules.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\nnVersion\n\n\nint\n\n\nThe block version number indicates which set of block validation rules to follow. See the list of block versions below.\n\n\n\n\n\n\n32\n\n\nhashPrevBlock\n\n\nuint256\n\n\nA SHA256(SHA256()) hash in internal byte order of the previous block's header.  This ensures no previous block can be changed without also changing this block's header.\n\n\n\n\n\n\n32\n\n\nhashMerkleRoot\n\n\nuint256\n\n\nA SHA256(SHA256()) hash in internal byte order. The merkle root is derived from the hashes of all transactions included in this block, ensuring that none of those transactions can be modified without modifying the header.  See the merkle trees section below.\n\n\n\n\n\n\n4\n\n\nnTime\n\n\nunsigned int\n\n\nThe block time is a Unix epoch time when the miner started hashing the header (according to the miner).  Must be strictly greater than the median time of the previous 11 blocks.  Full nodes will not accept blocks with headers more than two hours in the future according to their clock.\n\n\n\n\n\n\n4\n\n\nnBits\n\n\nunsigned int\n\n\nAn encoded version of the target threshold this block's header hash must be less than or equal to.  See the nBits format described below.\n\n\n\n\n\n\n4\n\n\nnNonce\n\n\nunsigned int\n\n\nAn arbitrary number miners change to modify the header hash in order to produce a hash less than or equal to the target threshold.  If all 32-bit values are tested, the time can be updated or the coinbase transaction can be changed and the merkle root updated.\n\n\n\n\n\n\n\n\nThe hashes are in internal byte order; the other values are all\nin little-endian order.\n\n\nAn example header in hex:\n\n\n02000000 ........................... Block version: 2\n\nb6ff0b1b1680a2862a30ca44d346d9e8\n910d334beb48ca0c0000000000000000 ... Hash of previous block's header\n9d10aa52ee949386ca9385695f04ede2\n70dda20810decd12bc9b048aaab31471 ... Merkle root\n\n24d95a54 ........................... Unix time: 1415239972\n30c31b18 ........................... Target: 0x1bc330 * 256**(0x18-3)\nfe9f0864 ........................... Nonce\n\n\n\n\nBlock Versions\n\n\n\n\nVersion 1\n was introduced in the genesis block of the current Pinkcoin blockchain (Pinkcoin migrated to this new blockchain on March 8, 2017).\n\n\n\n\nMerkle Trees\n\n\nThe merkle root is constructed using all the TXIDs of transactions in\nthis block, but first the TXIDs are placed in order as required by the\nconsensus rules:\n\n\n\n\n\n\nThe coinbase transaction's TXID is always placed first.\n\n\n\n\n\n\nAny input within this block can spend an output which also appears in\n  this block (assuming the spend is otherwise valid). However, the TXID\n  corresponding to the output must be placed at some point before the\n  TXID corresponding to the input. This ensures that any program parsing\n  block chain transactions linearly will encounter each output before it\n  is used as an input.\n\n\n\n\n\n\nIf a block only has a coinbase transaction, the coinbase TXID is used as\nthe merkle root hash.\n\n\nIf a block only has a coinbase transaction and one other transaction,\nthe TXIDs of those two transactions are placed in order, concatenated as\n64 raw bytes, and then SHA256(SHA256()) hashed together to form the\nmerkle root.\n\n\nIf a block has three or more transactions, intermediate merkle tree rows\nare formed. The TXIDs are placed in order and paired, starting with the\ncoinbase transaction's TXID. Each pair is concatenated together as 64\nraw bytes and SHA256(SHA256()) hashed to form a second row of\nhashes. If there are an odd (non-even) number of TXIDs, the last TXID is\nconcatenated with a copy of itself and hashed. If there are more than\ntwo hashes in the second row, the process is repeated to create a third\nrow (and, if necessary, repeated further to create additional rows).\nOnce a row is obtained with only two hashes, those hashes are concatenated and\nhashed to produce the merkle root..\n\n\n\n\nTXIDs and intermediate hashes are always in internal byte order when they're\nconcatenated, and the resulting merkle root is also in internal byte\norder when it's placed in the block header.\n\n\nTarget nBits\n\n\nThe target threshold is a 256-bit unsigned integer which a header hash\nmust be equal to or below in order for that header to be a valid part of\nthe block chain.\nHowever, the header field \nnBits\n provides only 32 bits of space, so the\ntarget number uses a less precise format called \"compact\" which works\nlike a base-256 version of scientific notation:\n\n\n\n\nAs a base-256 number, nBits can be quickly parsed as bytes the same way\nyou might parse a decimal number in base-10 scientific notation:\n\n\n\n\nAlthough the target threshold should be an unsigned integer, the\noriginal nBits implementation inherits properties from a signed data\nclass, allowing the target threshold to be negative if the high bit of\nthe significand is set. This is useless---the header hash is\ntreated as an unsigned number, so it can never be equal to or lower than a\nnegative target threshold. Pinkcoin Core deals with this in two ways:\n\n\n\n\n\n\nWhen parsing nBits, Pinkcoin Core converts a negative target\n  threshold into a target of zero, which the header hash can equal (in\n  theory, at least).\n\n\n\n\n\n\nWhen creating a value for nBits, Pinkcoin Core checks to see if it will\n  produce an nBits which will be interpreted as negative; if so, it\n  divides the significand by 256 and increases the exponent by 1 to\n  produce the same number with a different encoding.\n\n\n\n\n\n\nSome examples taken from the Pinkcoin Core test cases:\n\n\n\n\n\n\n\n\nnBits\n\n\nTarget\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\n0x01003456\n\n\n0x00\n\n\n\n\n\n\n\n\n0x01123456\n\n\n0x12\n\n\n\n\n\n\n\n\n0x02008000\n\n\n0x80\n\n\n\n\n\n\n\n\n0x05009234\n\n\n0x92340000\n\n\n\n\n\n\n\n\n0x04923456\n\n\n-0x12345600\n\n\nHigh bit set (0x80 in 0x92).\n\n\n\n\n\n\n0x04123456\n\n\n0x12345600\n\n\nInverse of above; no high bit.\n\n\n\n\n\n\n\n\nDifficulty 1, the minimum allowed difficulty, is represented on mainnet\nand the current testnet by the nBits value 0x1d00ffff. Regtest mode uses\na different difficulty 1 value---0x207fffff, the highest possible value\nbelow uint32_max which can be encoded; this allows near-instant building\nof blocks in regtest mode.\n\n\nSerialized Blocks\n\n\nUnder current consensus rules, a block is not valid unless its\nserialized size is less than or equal to 1 MB. All fields described\nbelow are counted towards the serialized size.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n80\n\n\nblock header\n\n\nblock_header\n\n\nThe block header in the format described in the \nblock header section\n.\n\n\n\n\n\n\nVaries\n\n\ntxn_count\n\n\ncompactSize uint\n\n\nThe total number of transactions in this block, including the coinbase transaction.\n\n\n\n\n\n\nVaries\n\n\ntxns\n\n\nraw transaction\n\n\nEvery transaction in this block, one after another, in raw transaction format.  Transactions must appear in the data stream in the same order their TXIDs appeared in the first row of the merkle tree.  See the \nmerkle tree section\n for details.\n\n\n\n\n\n\n\n\nThe first transaction in a block must be a coinbase\ntransaction which should collect and\nspend any transaction fees paid by transactions included in this block.\n\n\nAll blocks with a block height less than 6,930,000 are entitled to\nreceive a block subsidy of newly created pinkcoin value, which also\nshould be spent in the coinbase transaction. (The block subsidy started\nat 50 pinkcoins and is being halved every 210,000 blocks---approximately\nonce every four years. As of November 2017, it's 12.5 pinkcoins.)\n\n\nTogether, the transaction fees and block subsidy are called the block\nreward. A coinbase transaction is\ninvalid if it tries to spend more value than is available from the\nblock reward.", 
            "title": "Blockchain"
        }, 
        {
            "location": "/block-chain/#block-headers", 
            "text": "Block headers are serialized in the 80-byte format described below and then\nhashed as part of Pinkcoin's proof-of-work algorithm, making the\nserialized header format part of the consensus rules.     Bytes  Name  Data Type  Description      4  nVersion  int  The block version number indicates which set of block validation rules to follow. See the list of block versions below.    32  hashPrevBlock  uint256  A SHA256(SHA256()) hash in internal byte order of the previous block's header.  This ensures no previous block can be changed without also changing this block's header.    32  hashMerkleRoot  uint256  A SHA256(SHA256()) hash in internal byte order. The merkle root is derived from the hashes of all transactions included in this block, ensuring that none of those transactions can be modified without modifying the header.  See the merkle trees section below.    4  nTime  unsigned int  The block time is a Unix epoch time when the miner started hashing the header (according to the miner).  Must be strictly greater than the median time of the previous 11 blocks.  Full nodes will not accept blocks with headers more than two hours in the future according to their clock.    4  nBits  unsigned int  An encoded version of the target threshold this block's header hash must be less than or equal to.  See the nBits format described below.    4  nNonce  unsigned int  An arbitrary number miners change to modify the header hash in order to produce a hash less than or equal to the target threshold.  If all 32-bit values are tested, the time can be updated or the coinbase transaction can be changed and the merkle root updated.     The hashes are in internal byte order; the other values are all\nin little-endian order.  An example header in hex:  02000000 ........................... Block version: 2\n\nb6ff0b1b1680a2862a30ca44d346d9e8\n910d334beb48ca0c0000000000000000 ... Hash of previous block's header\n9d10aa52ee949386ca9385695f04ede2\n70dda20810decd12bc9b048aaab31471 ... Merkle root\n\n24d95a54 ........................... Unix time: 1415239972\n30c31b18 ........................... Target: 0x1bc330 * 256**(0x18-3)\nfe9f0864 ........................... Nonce", 
            "title": "Block Headers"
        }, 
        {
            "location": "/block-chain/#block-versions", 
            "text": "Version 1  was introduced in the genesis block of the current Pinkcoin blockchain (Pinkcoin migrated to this new blockchain on March 8, 2017).", 
            "title": "Block Versions"
        }, 
        {
            "location": "/block-chain/#merkle-trees", 
            "text": "The merkle root is constructed using all the TXIDs of transactions in\nthis block, but first the TXIDs are placed in order as required by the\nconsensus rules:    The coinbase transaction's TXID is always placed first.    Any input within this block can spend an output which also appears in\n  this block (assuming the spend is otherwise valid). However, the TXID\n  corresponding to the output must be placed at some point before the\n  TXID corresponding to the input. This ensures that any program parsing\n  block chain transactions linearly will encounter each output before it\n  is used as an input.    If a block only has a coinbase transaction, the coinbase TXID is used as\nthe merkle root hash.  If a block only has a coinbase transaction and one other transaction,\nthe TXIDs of those two transactions are placed in order, concatenated as\n64 raw bytes, and then SHA256(SHA256()) hashed together to form the\nmerkle root.  If a block has three or more transactions, intermediate merkle tree rows\nare formed. The TXIDs are placed in order and paired, starting with the\ncoinbase transaction's TXID. Each pair is concatenated together as 64\nraw bytes and SHA256(SHA256()) hashed to form a second row of\nhashes. If there are an odd (non-even) number of TXIDs, the last TXID is\nconcatenated with a copy of itself and hashed. If there are more than\ntwo hashes in the second row, the process is repeated to create a third\nrow (and, if necessary, repeated further to create additional rows).\nOnce a row is obtained with only two hashes, those hashes are concatenated and\nhashed to produce the merkle root..   TXIDs and intermediate hashes are always in internal byte order when they're\nconcatenated, and the resulting merkle root is also in internal byte\norder when it's placed in the block header.", 
            "title": "Merkle Trees"
        }, 
        {
            "location": "/block-chain/#target-nbits", 
            "text": "The target threshold is a 256-bit unsigned integer which a header hash\nmust be equal to or below in order for that header to be a valid part of\nthe block chain.\nHowever, the header field  nBits  provides only 32 bits of space, so the\ntarget number uses a less precise format called \"compact\" which works\nlike a base-256 version of scientific notation:   As a base-256 number, nBits can be quickly parsed as bytes the same way\nyou might parse a decimal number in base-10 scientific notation:   Although the target threshold should be an unsigned integer, the\noriginal nBits implementation inherits properties from a signed data\nclass, allowing the target threshold to be negative if the high bit of\nthe significand is set. This is useless---the header hash is\ntreated as an unsigned number, so it can never be equal to or lower than a\nnegative target threshold. Pinkcoin Core deals with this in two ways:    When parsing nBits, Pinkcoin Core converts a negative target\n  threshold into a target of zero, which the header hash can equal (in\n  theory, at least).    When creating a value for nBits, Pinkcoin Core checks to see if it will\n  produce an nBits which will be interpreted as negative; if so, it\n  divides the significand by 256 and increases the exponent by 1 to\n  produce the same number with a different encoding.    Some examples taken from the Pinkcoin Core test cases:     nBits  Target  Notes      0x01003456  0x00     0x01123456  0x12     0x02008000  0x80     0x05009234  0x92340000     0x04923456  -0x12345600  High bit set (0x80 in 0x92).    0x04123456  0x12345600  Inverse of above; no high bit.     Difficulty 1, the minimum allowed difficulty, is represented on mainnet\nand the current testnet by the nBits value 0x1d00ffff. Regtest mode uses\na different difficulty 1 value---0x207fffff, the highest possible value\nbelow uint32_max which can be encoded; this allows near-instant building\nof blocks in regtest mode.", 
            "title": "Target nBits"
        }, 
        {
            "location": "/block-chain/#serialized-blocks", 
            "text": "Under current consensus rules, a block is not valid unless its\nserialized size is less than or equal to 1 MB. All fields described\nbelow are counted towards the serialized size.     Bytes  Name  Data Type  Description      80  block header  block_header  The block header in the format described in the  block header section .    Varies  txn_count  compactSize uint  The total number of transactions in this block, including the coinbase transaction.    Varies  txns  raw transaction  Every transaction in this block, one after another, in raw transaction format.  Transactions must appear in the data stream in the same order their TXIDs appeared in the first row of the merkle tree.  See the  merkle tree section  for details.     The first transaction in a block must be a coinbase\ntransaction which should collect and\nspend any transaction fees paid by transactions included in this block.  All blocks with a block height less than 6,930,000 are entitled to\nreceive a block subsidy of newly created pinkcoin value, which also\nshould be spent in the coinbase transaction. (The block subsidy started\nat 50 pinkcoins and is being halved every 210,000 blocks---approximately\nonce every four years. As of November 2017, it's 12.5 pinkcoins.)  Together, the transaction fees and block subsidy are called the block\nreward. A coinbase transaction is\ninvalid if it tries to spend more value than is available from the\nblock reward.", 
            "title": "Serialized Blocks"
        }, 
        {
            "location": "/transactions/", 
            "text": "OpCodes\n\n\nThe opcodes used in the pubkey scripts of standard transactions are:\n\n\n\n\n\n\nVarious data pushing opcodes from 0x00 to 0x4e (1--78). These aren't\n  typically shown in examples, but they must be used to push\n  signatures and public keys onto the stack. See the link below this list\n  for a description.\n\n\n\n\n\n\nOP_TRUE\n/\nOP_1\n (0x51) and \nOP_2\n through \nOP_16\n (0x52--0x60), which\n  push the values 1 through 16 to the stack.\n\n\n\n\n\n\nOP_CHECKSIG\n consumes a signature and a full public key, and pushes\n  true onto the stack if the transaction data specified by the SIGHASH flag was\n  converted into the signature using the same ECDSA private key that\n  generated the public key.  Otherwise, it pushes false onto the stack.\n\n\n\n\n\n\nOP_DUP\n pushes a copy of the topmost stack item on to the stack.\n\n\n\n\n\n\nOP_HASH160\n consumes the topmost item on the stack,\n  computes the RIPEMD160(SHA256()) hash of that item, and pushes that hash onto the stack.\n\n\n\n\n\n\nOP_EQUAL\n consumes the top two items on the stack, compares them, and\n  pushes true onto the stack if they are the same, false if not.\n\n\n\n\n\n\nOP_VERIFY\n consumes the topmost item on the stack.\n  If that item is zero (false) it terminates the script in failure.\n\n\n\n\n\n\nOP_EQUALVERIFY\n runs \nOP_EQUAL\n and then \nOP_VERIFY\n in sequence.\n\n\n\n\n\n\nOP_CHECKMULTISIG\n consumes the value (n) at the top of the stack,\n  consumes that many of the next stack levels (public keys), consumes\n  the value (m) now at the top of the stack, and consumes that many of\n  the next values (signatures) plus one extra value.\n\n\nThe \"one extra value\" it consumes is the result of an off-by-one\nerror in the Bitcoin Core implementation. This value is not used, so\nsignature scripts prefix the list of secp256k1 signatures with a\nsingle OP_0 (0x00).\n\n\nOP_CHECKMULTISIG\n compares the first signature against each public\nkey until it finds an ECDSA match. Starting with the subsequent\npublic key, it compares the second signature against each remaining\npublic key until it finds an ECDSA match. The process is repeated\nuntil all signatures have been checked or not enough public keys\nremain to produce a successful result.\n\n\nBecause public keys are not checked again if they fail any signature\ncomparison, signatures must be placed in the signature script using\nthe same order as their corresponding public keys were placed in\nthe pubkey script or redeem script. See the \nOP_CHECKMULTISIG\n warning\nbelow for more details.\n\n\n\n\n\n\nOP_RETURN\n terminates the script in failure when executed.\n\n\n\n\n\n\nA complete list of opcodes can be found in the \nopcodetype\n enum\nof the Bitcoin Core script header file\n\n\n\n\nSignature script modification warning:\n\nSignature scripts are not signed, so anyone can modify them. This\nmeans signature scripts should only contain data and data-pushing opcodes\nwhich can't be modified without causing the pubkey script to fail.\nPlacing non-data-pushing opcodes in the signature script currently\nmakes a transaction non-standard, and future consensus rules may forbid\nsuch transactions altogether. (Non-data-pushing opcodes are already\nforbidden in signature scripts when spending a P2SH pubkey script.)\n\n\n\n\nOP_CHECKMULTISIG\n warning:\n The multisig verification process\ndescribed above requires that signatures in the signature script be\nprovided in the same order as their corresponding public keys in\nthe pubkey script or redeem script. For example, the following\ncombined signature and pubkey script will produce the stack and\ncomparisons shown:\n\n\nOP_0 \nA sig\n \nB sig\n OP_2 \nA pubkey\n \nB pubkey\n \nC pubkey\n OP_3\n\nSig Stack       Pubkey Stack  (Actually a single stack)\n---------       ------------\nB sig           C pubkey\nA sig           B pubkey\nOP_0            A pubkey\n\n1. B sig compared to C pubkey (no match)\n2. B sig compared to B pubkey (match #1)\n3. A sig compared to A pubkey (match #2)\n\nSuccess: two matches found\n\n\n\n\nBut reversing the order of the signatures with everything else the same\nwill fail, as shown below:\n\n\nOP_0 \nB sig\n \nA sig\n OP_2 \nA pubkey\n \nB pubkey\n \nC pubkey\n OP_3\n\nSig Stack       Pubkey Stack  (Actually a single stack)\n---------       ------------\nA sig           C pubkey\nB sig           B pubkey\nOP_0            A pubkey\n\n1. A sig compared to C pubkey (no match)\n2. A sig compared to B pubkey (no match)\n\nFailure, aborted: two signature matches required but none found so\n                  far, and there's only one pubkey remaining\n\n\n\n\nAddress Conversion\n\n\nThe hashes used in P2PKH and P2SH outputs are commonly encoded as Bitcoin\naddresses.  This is the procedure to encode those hashes and decode the\naddresses.\n\n\nFirst, get your hash.  For P2PKH, you RIPEMD-160(SHA256()) hash a ECDSA\npublic key derived from your 256-bit ECDSA private key (random data).\nFor P2SH, you RIPEMD-160(SHA256()) hash a redeem script serialized in the\nformat used in raw transactions (described in a [following\nsub-section][raw transaction format]).  Taking the resulting hash:\n\n\n\n\n\n\nAdd an address version byte in front of the hash.  The version\nbytes commonly used by Bitcoin are:\n\n\n\n\n\n\n0x00 for P2PKH addresses on the main Bitcoin network (mainnet)\n\n\n\n\n\n\n0x6f for P2PKH addresses on the Bitcoin testing network (testnet)\n\n\n\n\n\n\n0x05 for P2SH addresses on mainnet\n\n\n\n\n\n\n0xc4 for P2SH addresses on testnet\n\n\n\n\n\n\n\n\n\n\nCreate a copy of the version and hash; then hash that twice with SHA256: \nSHA256(SHA256(version . hash))\n\n\n\n\n\n\nExtract the first four bytes from the double-hashed copy.\n   These are used as a checksum to ensure the base hash gets transmitted\n   correctly.\n\n\n\n\n\n\nAppend the checksum to the version and hash, and encode it as a base58\n   string: \nBASE58(version . hash . checksum)\n\n\n\n\n\n\nBitcoin's base58 encoding, called Base58Check may not match other implementations. Tier\nNolan provided the following example encoding algorithm to the Bitcoin\nWiki Base58Check\nencoding page under\nthe Creative Commons Attribution 3.0 license:\n\n\ncode_string = \n123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\n\nx = convert_bytes_to_big_integer(hash_result)\n\noutput_string = \n\n\nwhile(x \n 0) \n   {\n       (x, remainder) = divide(x, 58)\n       output_string.append(code_string[remainder])\n   }\n\nrepeat(number_of_leading_zero_bytes_in_hash)\n   {\n   output_string.append(code_string[0]);\n   }\n\noutput_string.reverse();\n\n\n\n\nBitcoin's own code can be traced using the base58 header\nfile.\nTo convert addresses back into hashes, reverse the base58 encoding, extract\nthe checksum, repeat the steps to create the checksum and compare it\nagainst the extracted checksum, and then remove the version byte.\n\n\nRaw Transaction Format\n\n\nBitcoin transactions are broadcast between peers\nin a serialized byte format, called raw format.\nIt is this form of a transaction which is SHA256(SHA256()) hashed to create\nthe TXID and, ultimately, the merkle root of a block containing the\ntransaction---making the transaction format part of the consensus rules.\n\n\nBitcoin Core and many other tools print and accept raw transactions\nencoded as hex.\n\n\nAs of Bitcoin Core 0.9.3 (October 2014), all transactions use the\nversion 1 format described below. (Note: transactions in the block chain\nare allowed to list a higher version number to permit soft forks, but\nthey are treated as version 1 transactions by current software.)\n\n\nA raw transaction has the following top-level format:\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\nversion\n\n\nuint32_t\n\n\nTransaction version number; currently version 1.  Programs creating transactions using newer consensus rules may use higher version numbers.\n\n\n\n\n\n\nVaries\n\n\ntx_in count\n\n\ncompactSize uint\n\n\nNumber of inputs in this transaction.\n\n\n\n\n\n\nVaries\n\n\ntx_in\n\n\ntxIn\n\n\nTransaction inputs.  See description of txIn below.\n\n\n\n\n\n\nVaries\n\n\ntx_out count\n\n\ncompactSize uint\n\n\nNumber of outputs in this transaction.\n\n\n\n\n\n\nVaries\n\n\ntx_out\n\n\ntxOut\n\n\nTransaction outputs.  See description of txOut below.\n\n\n\n\n\n\n4\n\n\nlock_time\n\n\nuint32_t\n\n\nA time (Unix epoch time) or block number.  See the locktime parsing rules.\n\n\n\n\n\n\n\n\nA transaction may have multiple inputs and outputs, so the txIn and\ntxOut structures may recur within a transaction. CompactSize unsigned\nintegers are a form of variable-length integers; they are described in\nthe CompactSize section.\n\n\nTxIn: A Transaction Input (Non-Coinbase) {#txin}\n\n\nEach non-coinbase input spends an outpoint from a previous transaction.\n(Coinbase inputs are described separately after the example section below.)\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n36\n\n\nprevious_output\n\n\noutpoint\n\n\nThe previous outpoint being spent.  See description of outpoint below.\n\n\n\n\n\n\nVaries\n\n\nscript bytes\n\n\ncompactSize uint\n\n\nThe number of bytes in the signature script.  Maximum is 10,000 bytes.\n\n\n\n\n\n\nVaries\n\n\nsignature script\n\n\nchar[]\n\n\nA script-language script which satisfies the conditions placed in the outpoint's pubkey script.  Should only contain data pushes; see the [signature script modification warning][].\n\n\n\n\n\n\n4\n\n\nsequence\n\n\nuint32_t\n\n\nSequence number.  Default for Bitcoin Core and almost all other programs is 0xffffffff.\n\n\n\n\n\n\n\n\nOutpoint: The Specific Part Of A Specific Output {#outpoint}\n\n\nBecause a single transaction can include multiple outputs, the outpoint\nstructure includes both a TXID and an output index number to refer to\nspecific output.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n32\n\n\nhash\n\n\nchar[32]\n\n\nThe TXID of the transaction holding the output to spend.  The TXID is a hash provided here in internal byte order.\n\n\n\n\n\n\n4\n\n\nindex\n\n\nuint32_t\n\n\nThe output index number of the specific output to spend from the transaction. The first output is 0x00000000.\n\n\n\n\n\n\n\n\nTxOut: A Transaction Output {#txout}\n\n\nEach output spends a certain number of satoshis, placing them under\ncontrol of anyone who can satisfy the provided pubkey script.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n8\n\n\nvalue\n\n\nint64_t\n\n\nNumber of satoshis to spend.  May be zero; the sum of all outputs may not exceed the sum of satoshis previously spent to the outpoints provided in the input section.  (Exception: coinbase transactions spend the block subsidy and collected transaction fees.)\n\n\n\n\n\n\n1+\n\n\npk_script bytes\n\n\ncompactSize uint\n\n\nNumber of bytes in the pubkey script.  Maximum is 10,000 bytes.\n\n\n\n\n\n\nVaries\n\n\npk_script\n\n\nchar[]\n\n\nDefines the conditions which must be satisfied to spend this output.\n\n\n\n\n\n\n\n\nExample\n\n\nThe sample raw transaction itemized below is the one created in the\nSimple Raw Transaction section of the\nDeveloper Examples. It spends a previous pay-to-pubkey output by paying\nto a new pay-to-pubkey-hash (P2PKH) output.\n\n\n01000000 ................................... Version\n\n01 ......................................... Number of inputs\n|\n| 7b1eabe0209b1fe794124575ef807057\n| c77ada2138ae4fa8d6c4de0398a14f3f ......... Outpoint TXID\n| 00000000 ................................. Outpoint index number\n|\n| 49 ....................................... Bytes in sig. script: 73\n| | 48 ..................................... Push 72 bytes as data\n| | | 30450221008949f0cb400094ad2b5eb3\n| | | 99d59d01c14d73d8fe6e96df1a7150de\n| | | b388ab8935022079656090d7f6bac4c9\n| | | a94e0aad311a4268e082a725f8aeae05\n| | | 73fb12ff866a5f01 ..................... Secp256k1 signature\n|\n| ffffffff ................................. Sequence number: UINT32_MAX\n\n01 ......................................... Number of outputs\n| f0ca052a01000000 ......................... Satoshis (49.99990000 BTC)\n|\n| 19 ....................................... Bytes in pubkey script: 25\n| | 76 ..................................... OP_DUP\n| | a9 ..................................... OP_HASH160\n| | 14 ..................................... Push 20 bytes as data\n| | | cbc20a7664f2f69e5355aa427045bc15\n| | | e7c6c772 ............................. PubKey hash\n| | 88 ..................................... OP_EQUALVERIFY\n| | ac ..................................... OP_CHECKSIG\n\n00000000 ................................... locktime: 0 (a block height)\n\n\n\n\nCoinbase Input: The Input Of The First Transaction In A Block {#coinbase}\n\n\nThe first transaction in a block, called the coinbase transaction, must\nhave exactly one input, called a coinbase. The coinbase input currently\nhas the following format.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n32\n\n\nhash (null)\n\n\nchar[32]\n\n\nA 32-byte null, as a coinbase has no previous outpoint.\n\n\n\n\n\n\n4\n\n\nindex (UINT32_MAX)\n\n\nuint32_t\n\n\n0xffffffff, as a coinbase has no previous outpoint.\n\n\n\n\n\n\nVaries\n\n\nscript bytes\n\n\ncompactSize uint\n\n\nThe number of bytes in the coinbase script, up to a maximum of 100 bytes.\n\n\n\n\n\n\nVaries\n (4)\n\n\nheight\n\n\nscript\n\n\nThe block height of this block as required by BIP34.  Uses script language: starts with a data-pushing opcode that indicates how many bytes to push to the stack followed by the block height as a little-endian unsigned integer.  This script must be as short as possible, otherwise it may be rejected.\n  The data-pushing opcode will be 0x03 and the total size four bytes until block 16,777,216 about 300 years from now.\n\n\n\n\n\n\nVaries\n\n\ncoinbase script\n\n\nNone\n\n\nThe coinbase field Arbitrary data not exceeding 100 bytes minus the (4) height bytes.  Miners commonly place an extra nonce in this field to update the block header merkle root during hashing.\n\n\n\n\n\n\n4\n\n\nsequence\n\n\nuint32_t\n\n\nSequence number.\n\n\n\n\n\n\n\n\nMost (but not all) blocks prior to block height 227,836 used block\nversion 1 which did not require the height parameter to be prefixed to\nthe coinbase script.  The block height parameter is now required.\n\n\nAlthough the coinbase script is arbitrary data, if it includes the\nbytes used by any signature-checking operations such as \nOP_CHECKSIG\n,\nthose signature checks will be counted as signature operations (sigops)\ntowards the block's sigop limit.  To avoid this, you can prefix all data\nwith the appropriate push operation.\n\n\nAn itemized coinbase transaction:\n\n\n01000000 .............................. Version\n\n01 .................................... Number of inputs\n| 00000000000000000000000000000000\n| 00000000000000000000000000000000 ...  Previous outpoint TXID\n| ffffffff ............................ Previous outpoint index\n|\n| 29 .................................. Bytes in coinbase\n| |\n| | 03 ................................ Bytes in height\n| | | 4e0105 .......................... Height: 328014\n| |\n| | 062f503253482f0472d35454085fffed\n| | f2400000f90f54696d65202620486561\n| | 6c74682021 ........................ Arbitrary data\n| 00000000 ............................ Sequence\n\n01 .................................... Output count\n| 2c37449500000000 .................... Satoshis (25.04275756 BTC)\n| 1976a914a09be8040cbf399926aeb1f4\n| 70c37d1341f3b46588ac ................ P2PKH script\n| 00000000 ............................ Locktime\n\n\n\n\nCompactSize Unsigned Integers\n\n\nThe raw transaction format and several peer-to-peer network messages use\na type of variable-length integer to indicate the number of bytes in a\nfollowing piece of data.\n\n\nBitcoin Core code and this document refers to these variable length\nintegers as compactSize. Many other documents refer to them as var_int\nor varInt, but this risks conflation with other variable-length integer\nencodings---such as the CVarInt class used in Bitcoin Core for\nserializing data to disk.  Because it's used in the transaction format,\nthe format of compactSize unsigned integers is part of the consensus\nrules.\n\n\nFor numbers from 0 to 252, compactSize unsigned integers look like\nregular unsigned integers. For other numbers up to 0xffffffffffffffff, a\nbyte is prefixed to the number to indicate its length---but otherwise\nthe numbers look like regular unsigned integers in little-endian order.\n\n\n\n\n\n\n\n\nValue\n\n\nBytes Used\n\n\nFormat\n\n\n\n\n\n\n\n\n\n\n= 0 \n \n= 252\n\n\n1\n\n\nuint8_t\n\n\n\n\n\n\n= 253 \n \n= 0xffff\n\n\n3\n\n\n0xfd followed by the number as uint16_t\n\n\n\n\n\n\n= 0x10000 \n \n= 0xffffffff\n\n\n5\n\n\n0xfe followed by the number as uint32_t\n\n\n\n\n\n\n= 0x100000000 \n \n= 0xffffffffffffffff\n\n\n9\n\n\n0xff followed by the number as uint64_t\n\n\n\n\n\n\n\n\nFor example, the number 515 is encoded as 0xfd0302.", 
            "title": "Transactions"
        }, 
        {
            "location": "/transactions/#opcodes", 
            "text": "The opcodes used in the pubkey scripts of standard transactions are:    Various data pushing opcodes from 0x00 to 0x4e (1--78). These aren't\n  typically shown in examples, but they must be used to push\n  signatures and public keys onto the stack. See the link below this list\n  for a description.    OP_TRUE / OP_1  (0x51) and  OP_2  through  OP_16  (0x52--0x60), which\n  push the values 1 through 16 to the stack.    OP_CHECKSIG  consumes a signature and a full public key, and pushes\n  true onto the stack if the transaction data specified by the SIGHASH flag was\n  converted into the signature using the same ECDSA private key that\n  generated the public key.  Otherwise, it pushes false onto the stack.    OP_DUP  pushes a copy of the topmost stack item on to the stack.    OP_HASH160  consumes the topmost item on the stack,\n  computes the RIPEMD160(SHA256()) hash of that item, and pushes that hash onto the stack.    OP_EQUAL  consumes the top two items on the stack, compares them, and\n  pushes true onto the stack if they are the same, false if not.    OP_VERIFY  consumes the topmost item on the stack.\n  If that item is zero (false) it terminates the script in failure.    OP_EQUALVERIFY  runs  OP_EQUAL  and then  OP_VERIFY  in sequence.    OP_CHECKMULTISIG  consumes the value (n) at the top of the stack,\n  consumes that many of the next stack levels (public keys), consumes\n  the value (m) now at the top of the stack, and consumes that many of\n  the next values (signatures) plus one extra value.  The \"one extra value\" it consumes is the result of an off-by-one\nerror in the Bitcoin Core implementation. This value is not used, so\nsignature scripts prefix the list of secp256k1 signatures with a\nsingle OP_0 (0x00).  OP_CHECKMULTISIG  compares the first signature against each public\nkey until it finds an ECDSA match. Starting with the subsequent\npublic key, it compares the second signature against each remaining\npublic key until it finds an ECDSA match. The process is repeated\nuntil all signatures have been checked or not enough public keys\nremain to produce a successful result.  Because public keys are not checked again if they fail any signature\ncomparison, signatures must be placed in the signature script using\nthe same order as their corresponding public keys were placed in\nthe pubkey script or redeem script. See the  OP_CHECKMULTISIG  warning\nbelow for more details.    OP_RETURN  terminates the script in failure when executed.    A complete list of opcodes can be found in the  opcodetype  enum\nof the Bitcoin Core script header file   Signature script modification warning: \nSignature scripts are not signed, so anyone can modify them. This\nmeans signature scripts should only contain data and data-pushing opcodes\nwhich can't be modified without causing the pubkey script to fail.\nPlacing non-data-pushing opcodes in the signature script currently\nmakes a transaction non-standard, and future consensus rules may forbid\nsuch transactions altogether. (Non-data-pushing opcodes are already\nforbidden in signature scripts when spending a P2SH pubkey script.)   OP_CHECKMULTISIG  warning:  The multisig verification process\ndescribed above requires that signatures in the signature script be\nprovided in the same order as their corresponding public keys in\nthe pubkey script or redeem script. For example, the following\ncombined signature and pubkey script will produce the stack and\ncomparisons shown:  OP_0  A sig   B sig  OP_2  A pubkey   B pubkey   C pubkey  OP_3\n\nSig Stack       Pubkey Stack  (Actually a single stack)\n---------       ------------\nB sig           C pubkey\nA sig           B pubkey\nOP_0            A pubkey\n\n1. B sig compared to C pubkey (no match)\n2. B sig compared to B pubkey (match #1)\n3. A sig compared to A pubkey (match #2)\n\nSuccess: two matches found  But reversing the order of the signatures with everything else the same\nwill fail, as shown below:  OP_0  B sig   A sig  OP_2  A pubkey   B pubkey   C pubkey  OP_3\n\nSig Stack       Pubkey Stack  (Actually a single stack)\n---------       ------------\nA sig           C pubkey\nB sig           B pubkey\nOP_0            A pubkey\n\n1. A sig compared to C pubkey (no match)\n2. A sig compared to B pubkey (no match)\n\nFailure, aborted: two signature matches required but none found so\n                  far, and there's only one pubkey remaining", 
            "title": "OpCodes"
        }, 
        {
            "location": "/transactions/#address-conversion", 
            "text": "The hashes used in P2PKH and P2SH outputs are commonly encoded as Bitcoin\naddresses.  This is the procedure to encode those hashes and decode the\naddresses.  First, get your hash.  For P2PKH, you RIPEMD-160(SHA256()) hash a ECDSA\npublic key derived from your 256-bit ECDSA private key (random data).\nFor P2SH, you RIPEMD-160(SHA256()) hash a redeem script serialized in the\nformat used in raw transactions (described in a [following\nsub-section][raw transaction format]).  Taking the resulting hash:    Add an address version byte in front of the hash.  The version\nbytes commonly used by Bitcoin are:    0x00 for P2PKH addresses on the main Bitcoin network (mainnet)    0x6f for P2PKH addresses on the Bitcoin testing network (testnet)    0x05 for P2SH addresses on mainnet    0xc4 for P2SH addresses on testnet      Create a copy of the version and hash; then hash that twice with SHA256:  SHA256(SHA256(version . hash))    Extract the first four bytes from the double-hashed copy.\n   These are used as a checksum to ensure the base hash gets transmitted\n   correctly.    Append the checksum to the version and hash, and encode it as a base58\n   string:  BASE58(version . hash . checksum)    Bitcoin's base58 encoding, called Base58Check may not match other implementations. Tier\nNolan provided the following example encoding algorithm to the Bitcoin\nWiki Base58Check\nencoding page under\nthe Creative Commons Attribution 3.0 license:  code_string =  123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz \nx = convert_bytes_to_big_integer(hash_result)\n\noutput_string =  \n\nwhile(x   0) \n   {\n       (x, remainder) = divide(x, 58)\n       output_string.append(code_string[remainder])\n   }\n\nrepeat(number_of_leading_zero_bytes_in_hash)\n   {\n   output_string.append(code_string[0]);\n   }\n\noutput_string.reverse();  Bitcoin's own code can be traced using the base58 header\nfile.\nTo convert addresses back into hashes, reverse the base58 encoding, extract\nthe checksum, repeat the steps to create the checksum and compare it\nagainst the extracted checksum, and then remove the version byte.", 
            "title": "Address Conversion"
        }, 
        {
            "location": "/transactions/#raw-transaction-format", 
            "text": "Bitcoin transactions are broadcast between peers\nin a serialized byte format, called raw format.\nIt is this form of a transaction which is SHA256(SHA256()) hashed to create\nthe TXID and, ultimately, the merkle root of a block containing the\ntransaction---making the transaction format part of the consensus rules.  Bitcoin Core and many other tools print and accept raw transactions\nencoded as hex.  As of Bitcoin Core 0.9.3 (October 2014), all transactions use the\nversion 1 format described below. (Note: transactions in the block chain\nare allowed to list a higher version number to permit soft forks, but\nthey are treated as version 1 transactions by current software.)  A raw transaction has the following top-level format:     Bytes  Name  Data Type  Description      4  version  uint32_t  Transaction version number; currently version 1.  Programs creating transactions using newer consensus rules may use higher version numbers.    Varies  tx_in count  compactSize uint  Number of inputs in this transaction.    Varies  tx_in  txIn  Transaction inputs.  See description of txIn below.    Varies  tx_out count  compactSize uint  Number of outputs in this transaction.    Varies  tx_out  txOut  Transaction outputs.  See description of txOut below.    4  lock_time  uint32_t  A time (Unix epoch time) or block number.  See the locktime parsing rules.     A transaction may have multiple inputs and outputs, so the txIn and\ntxOut structures may recur within a transaction. CompactSize unsigned\nintegers are a form of variable-length integers; they are described in\nthe CompactSize section.", 
            "title": "Raw Transaction Format"
        }, 
        {
            "location": "/transactions/#txin-a-transaction-input-non-coinbase-txin", 
            "text": "Each non-coinbase input spends an outpoint from a previous transaction.\n(Coinbase inputs are described separately after the example section below.)     Bytes  Name  Data Type  Description      36  previous_output  outpoint  The previous outpoint being spent.  See description of outpoint below.    Varies  script bytes  compactSize uint  The number of bytes in the signature script.  Maximum is 10,000 bytes.    Varies  signature script  char[]  A script-language script which satisfies the conditions placed in the outpoint's pubkey script.  Should only contain data pushes; see the [signature script modification warning][].    4  sequence  uint32_t  Sequence number.  Default for Bitcoin Core and almost all other programs is 0xffffffff.", 
            "title": "TxIn: A Transaction Input (Non-Coinbase) {#txin}"
        }, 
        {
            "location": "/transactions/#outpoint-the-specific-part-of-a-specific-output-outpoint", 
            "text": "Because a single transaction can include multiple outputs, the outpoint\nstructure includes both a TXID and an output index number to refer to\nspecific output.     Bytes  Name  Data Type  Description      32  hash  char[32]  The TXID of the transaction holding the output to spend.  The TXID is a hash provided here in internal byte order.    4  index  uint32_t  The output index number of the specific output to spend from the transaction. The first output is 0x00000000.", 
            "title": "Outpoint: The Specific Part Of A Specific Output {#outpoint}"
        }, 
        {
            "location": "/transactions/#txout-a-transaction-output-txout", 
            "text": "Each output spends a certain number of satoshis, placing them under\ncontrol of anyone who can satisfy the provided pubkey script.     Bytes  Name  Data Type  Description      8  value  int64_t  Number of satoshis to spend.  May be zero; the sum of all outputs may not exceed the sum of satoshis previously spent to the outpoints provided in the input section.  (Exception: coinbase transactions spend the block subsidy and collected transaction fees.)    1+  pk_script bytes  compactSize uint  Number of bytes in the pubkey script.  Maximum is 10,000 bytes.    Varies  pk_script  char[]  Defines the conditions which must be satisfied to spend this output.     Example  The sample raw transaction itemized below is the one created in the\nSimple Raw Transaction section of the\nDeveloper Examples. It spends a previous pay-to-pubkey output by paying\nto a new pay-to-pubkey-hash (P2PKH) output.  01000000 ................................... Version\n\n01 ......................................... Number of inputs\n|\n| 7b1eabe0209b1fe794124575ef807057\n| c77ada2138ae4fa8d6c4de0398a14f3f ......... Outpoint TXID\n| 00000000 ................................. Outpoint index number\n|\n| 49 ....................................... Bytes in sig. script: 73\n| | 48 ..................................... Push 72 bytes as data\n| | | 30450221008949f0cb400094ad2b5eb3\n| | | 99d59d01c14d73d8fe6e96df1a7150de\n| | | b388ab8935022079656090d7f6bac4c9\n| | | a94e0aad311a4268e082a725f8aeae05\n| | | 73fb12ff866a5f01 ..................... Secp256k1 signature\n|\n| ffffffff ................................. Sequence number: UINT32_MAX\n\n01 ......................................... Number of outputs\n| f0ca052a01000000 ......................... Satoshis (49.99990000 BTC)\n|\n| 19 ....................................... Bytes in pubkey script: 25\n| | 76 ..................................... OP_DUP\n| | a9 ..................................... OP_HASH160\n| | 14 ..................................... Push 20 bytes as data\n| | | cbc20a7664f2f69e5355aa427045bc15\n| | | e7c6c772 ............................. PubKey hash\n| | 88 ..................................... OP_EQUALVERIFY\n| | ac ..................................... OP_CHECKSIG\n\n00000000 ................................... locktime: 0 (a block height)", 
            "title": "TxOut: A Transaction Output {#txout}"
        }, 
        {
            "location": "/transactions/#coinbase-input-the-input-of-the-first-transaction-in-a-block-coinbase", 
            "text": "The first transaction in a block, called the coinbase transaction, must\nhave exactly one input, called a coinbase. The coinbase input currently\nhas the following format.     Bytes  Name  Data Type  Description      32  hash (null)  char[32]  A 32-byte null, as a coinbase has no previous outpoint.    4  index (UINT32_MAX)  uint32_t  0xffffffff, as a coinbase has no previous outpoint.    Varies  script bytes  compactSize uint  The number of bytes in the coinbase script, up to a maximum of 100 bytes.    Varies  (4)  height  script  The block height of this block as required by BIP34.  Uses script language: starts with a data-pushing opcode that indicates how many bytes to push to the stack followed by the block height as a little-endian unsigned integer.  This script must be as short as possible, otherwise it may be rejected.   The data-pushing opcode will be 0x03 and the total size four bytes until block 16,777,216 about 300 years from now.    Varies  coinbase script  None  The coinbase field Arbitrary data not exceeding 100 bytes minus the (4) height bytes.  Miners commonly place an extra nonce in this field to update the block header merkle root during hashing.    4  sequence  uint32_t  Sequence number.     Most (but not all) blocks prior to block height 227,836 used block\nversion 1 which did not require the height parameter to be prefixed to\nthe coinbase script.  The block height parameter is now required.  Although the coinbase script is arbitrary data, if it includes the\nbytes used by any signature-checking operations such as  OP_CHECKSIG ,\nthose signature checks will be counted as signature operations (sigops)\ntowards the block's sigop limit.  To avoid this, you can prefix all data\nwith the appropriate push operation.  An itemized coinbase transaction:  01000000 .............................. Version\n\n01 .................................... Number of inputs\n| 00000000000000000000000000000000\n| 00000000000000000000000000000000 ...  Previous outpoint TXID\n| ffffffff ............................ Previous outpoint index\n|\n| 29 .................................. Bytes in coinbase\n| |\n| | 03 ................................ Bytes in height\n| | | 4e0105 .......................... Height: 328014\n| |\n| | 062f503253482f0472d35454085fffed\n| | f2400000f90f54696d65202620486561\n| | 6c74682021 ........................ Arbitrary data\n| 00000000 ............................ Sequence\n\n01 .................................... Output count\n| 2c37449500000000 .................... Satoshis (25.04275756 BTC)\n| 1976a914a09be8040cbf399926aeb1f4\n| 70c37d1341f3b46588ac ................ P2PKH script\n| 00000000 ............................ Locktime", 
            "title": "Coinbase Input: The Input Of The First Transaction In A Block {#coinbase}"
        }, 
        {
            "location": "/transactions/#compactsize-unsigned-integers", 
            "text": "The raw transaction format and several peer-to-peer network messages use\na type of variable-length integer to indicate the number of bytes in a\nfollowing piece of data.  Bitcoin Core code and this document refers to these variable length\nintegers as compactSize. Many other documents refer to them as var_int\nor varInt, but this risks conflation with other variable-length integer\nencodings---such as the CVarInt class used in Bitcoin Core for\nserializing data to disk.  Because it's used in the transaction format,\nthe format of compactSize unsigned integers is part of the consensus\nrules.  For numbers from 0 to 252, compactSize unsigned integers look like\nregular unsigned integers. For other numbers up to 0xffffffffffffffff, a\nbyte is prefixed to the number to indicate its length---but otherwise\nthe numbers look like regular unsigned integers in little-endian order.     Value  Bytes Used  Format      = 0    = 252  1  uint8_t    = 253    = 0xffff  3  0xfd followed by the number as uint16_t    = 0x10000    = 0xffffffff  5  0xfe followed by the number as uint32_t    = 0x100000000    = 0xffffffffffffffff  9  0xff followed by the number as uint64_t     For example, the number 515 is encoded as 0xfd0302.", 
            "title": "CompactSize Unsigned Integers"
        }, 
        {
            "location": "/p2p/", 
            "text": "This section describes the Bitcoin P2P network protocol (but it is not a\nspecification).\n\n\nAll peer-to-peer communication occurs entirely over TCP.\n\n\nNote:\n unless their description says otherwise, all multi-byte\nintegers mentioned in this section are transmitted in little-endian order.\n\n\nConstants And Defaults\n\n\nThe following constants and defaults are taken from Bitcoin Core's\nchainparams.cpp source code file.\n\n\n\n\n\n\n\n\nNetwork\n\n\nDefault Port\n\n\nStart String\n\n\nMax nBits\n\n\n\n\n\n\n\n\n\n\nMainnet\n\n\n8333\n\n\n0xf9beb4d9\n\n\n0x1d00ffff\n\n\n\n\n\n\nTestnet\n\n\n18333\n\n\n0x0b110907\n\n\n0x1d00ffff\n\n\n\n\n\n\nRegtest\n\n\n18444\n\n\n0xfabfb5da\n\n\n0x207fffff\n\n\n\n\n\n\n\n\nNote: the testnet start string and nBits above are for testnet3; the\noriginal testnet used a different string and higher (less difficult)\nnBits.\n\n\nCommand line parameters can change what port a node listens on (see\n\n-help\n). Start strings are hardcoded constants that appear at the start\nof all messages sent on the Bitcoin network; they may also appear in\ndata files such as Bitcoin Core's block database.  The nBits displayed\nabove are in big-endian order; they're sent over the network in\nlittle-endian order.\n\n\nBitcoin Core's chainparams.cpp also includes\nother constants useful to programs, such as the hash of the genesis\nblocks for the different networks.\n\n\nProtocol Versions\n\n\nThe table below lists some notable versions of the P2P network protocol,\nwith the most recent versions listed first. (If you know of a protocol\nversion that implemented a major change but which is not listed here,\nplease open an issue.)\n\n\nAs of Bitcoin Core 2.1.0.4, the most recent protocol version is 60014.\n\n\n\n\n\n\n\n\nVersion\n\n\nInitial Release\n\n\nMajor Changes\n\n\n\n\n\n\n\n\n\n\n60014\n\n\nPinkcoin Core v2.1.0.3\n\n\nHardforking Network Attack Bug-fix (\nDetails\n)\n\n\n\n\n\n\n\n\nMessage Headers\n\n\nAll messages in the network protocol use the same container format,\nwhich provides a required multi-field message header and an optional payload.\nThe message header format is:\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\nstart string\n\n\nchar[4]\n\n\nMagic bytes indicating the originating network; used to seek to next message when stream state is unknown.\n\n\n\n\n\n\n12\n\n\ncommand name\n\n\nchar[12]\n\n\nASCII string which identifies what message type is contained in the payload.  Followed by nulls (0x00) to pad out byte count; for example: \nversion\\0\\0\\0\\0\\0\n.\n\n\n\n\n\n\n4\n\n\npayload size\n\n\nuint32_t\n\n\nNumber of bytes in payload.  The current maximum number of bytes (\nMAX_SIZE\n) allowed in the payload by Bitcoin Core is 32 MiB---messages with a payload size larger than this will be dropped or rejected.\n\n\n\n\n\n\n4\n\n\nchecksum\n\n\nchar[4]\n\n\nAdded in protocol version 209.\n \nFirst 4 bytes of SHA256(SHA256(payload)) in internal byte order.\n If payload is empty, as in \nverack\n and \ngetaddr\n messages, the checksum is always 0x5df6e0e2 (SHA256(SHA256(\\\n))).\n\n\n\n\n\n\n\n\nThe following example is an annotated hex dump of a mainnet message\nheader from a \nverack\n message which has no payload.\n\n\nf9beb4d9 ................... Start string: Mainnet\n76657261636b000000000000 ... Command name: verack + null padding\n00000000 ................... Byte count: 0\n5df6e0e2 ................... Checksum: SHA256(SHA256(\nempty\n))\n\n\n\n\nData Messages\n\n\nThe following network messages all request or provide data related to\ntransactions and blocks.\n\n\n\n\nMany of the data messages use\ninventories as unique identifiers\nfor transactions and blocks.  Inventories have a simple 36-byte\nstructure:\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\ntype identifier\n\n\nuint32_t\n\n\nThe type of object which was hashed.  See list of type identifiers below.\n\n\n\n\n\n\n32\n\n\nhash\n\n\nchar[32]\n\n\nSHA256(SHA256()) hash of the object in internal byte order.\n\n\n\n\n\n\n\n\nThe currently-available type identifiers are:\n\n\n\n\n\n\n\n\nType Identifier\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1\n\n\nMSG_TX\n\n\nThe hash is a TXID.\n\n\n\n\n\n\n2\n\n\nMSG_BLOCK\n\n\nThe hash is of a block header.\n\n\n\n\n\n\n3\n\n\nMSG_FILTERED_BLOCK\n\n\nThe hash is of a block header; identical to \nMSG_BLOCK\n. When used in a \ngetdata\n message, this indicates the response should be a \nmerkleblock\n message rather than a \nblock\n message (but this only works if a bloom filter was previously configured).  \nOnly for use in \ngetdata\n messages.\n\n\n\n\n\n\n\n\nType identifier zero and type identifiers greater than three are reserved\nfor future implementations. Bitcoin Core ignores all inventories with\none of these unknown types.\n\n\nBlock\n\n\nThe \nblock\n message transmits a single serialized block in the format\ndescribed in the \nserialized blocks section\n.\nSee that section for an example hexdump.  It can be sent for two\ndifferent reasons:\n\n\n\n\n\n\nGetData Response:\n Nodes will always send it in response to a\n   \ngetdata\n message that requests the block with an inventory\n   type of \nMSG_BLOCK\n (provided the node has that block available for\n   relay).\n\n\n\n\n\n\nUnsolicited:\n Some miners will send unsolicited \nblock\n messages\n   broadcasting their newly-mined blocks to all of their peers. Many\n   mining pools do the same thing, although some may be misconfigured to\n   send the block from multiple nodes, possibly sending the same block\n   to some peers more than once.\n\n\n\n\n\n\nGetBlocks\n\n\nThe \ngetblocks\n message requests an \ninv\n message that provides block\nheader hashes starting from a particular point in the block chain. It\nallows a peer which has been disconnected or started for the first time\nto get the data it needs to request the blocks it hasn't seen.\n\n\nPeers which have been disconnected may have stale blocks in their\nlocally-stored block chain, so the \ngetblocks\n message allows the\nrequesting peer to provide the receiving peer with multiple header\nhashes at various heights on their local chain. This allows the\nreceiving peer to find, within that list, the last header hash they had\nin common and reply with all subsequent header hashes.\n\n\nNote: the receiving peer itself may respond with an \ninv\n message\ncontaining header hashes of stale blocks.  It is up to the requesting\npeer to poll all of its peers to find the best block chain.\n\n\nIf the receiving peer does not find a common header hash within the\nlist, it will assume the last common block was the genesis block (block\nzero), so it will reply with in \ninv\n message containing header hashes\nstarting with block one (the first block after the genesis block).\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\nversion\n\n\nuint32_t\n\n\nThe protocol version number; the same as sent in the \nversion\n message.\n\n\n\n\n\n\nVaries\n\n\nhash count\n\n\ncompactSize uint\n\n\nThe number of header hashes provided not including the stop hash.  There is no limit except that the byte size of the entire message must be below the \nMAX_SIZE\n limit; typically from 1 to 200 hashes are sent.\n\n\n\n\n\n\nVaries\n\n\nblock header hashes\n\n\nchar[32]\n\n\nOne or more block header hashes (32 bytes each) in internal byte order.  Hashes should be provided in reverse order of block height, so highest-height hashes are listed first and lowest-height hashes are listed last.\n\n\n\n\n\n\n32\n\n\nstop hash\n\n\nchar[32]\n\n\nThe header hash of the last header hash being requested; set to all zeroes to request an \ninv\n message with all subsequent header hashes (a maximum of 500 will be sent as a reply to this message; if you need more than 500, you will need to send another \ngetblocks\n message with a higher-height header hash as the first entry in block header hash field).\n\n\n\n\n\n\n\n\nThe following annotated hexdump shows a \ngetblocks\n message.  (The\nmessage header has been omitted.)\n\n\n71110100 ........................... Protocol version: 70001\n02 ................................. Hash count: 2\n\nd39f608a7775b537729884d4e6633bb2\n105e55a16a14d31b0000000000000000 ... Hash #1\n\n5c3e6403d40837110a2e8afb602b1c01\n714bda7ce23bea0a0000000000000000 ... Hash #2\n\n00000000000000000000000000000000\n00000000000000000000000000000000 ... Stop hash\n\n\n\n\nGetData\n\n\nThe \ngetdata\n message requests one or more data objects from another\nnode. The objects are requested by an inventory, which the requesting\nnode typically received previously by way of an \ninv\n message.\n\n\nThe response to a \ngetdata\n message can be a \ntx\n message, \nblock\n\nmessage, \nmerkleblock\n message, or \nnotfound\n message.\n\n\nThis message cannot be used to request arbitrary data, such as historic\ntransactions no longer in the memory pool or relay set. Full nodes may\nnot even be able to provide older blocks if they've pruned old\ntransactions from their block database. For this reason, the \ngetdata\n\nmessage should usually only be used to request data from a node which\npreviously advertised it had that data by sending an \ninv\n message.\n\n\nThe format and maximum size limitations of the \ngetdata\n message are\nidentical to the \ninv\n message; only the message header differs.\n\n\nGetHeaders\n\n\nThe \ngetheaders\n message requests a \nheaders\n message that provides block headers\nstarting from a particular point in the block chain. It allows a\npeer which has been disconnected or started for the first time to get\nthe headers it hasn\u2019t seen yet.\n\n\nThe \ngetheaders\n message is nearly identical to the \ngetblocks\n message,\nwith one minor difference: the \ninv\n reply to the \ngetblocks\n message\nwill include no more than 500 block header hashes; the \nheaders\n reply\nto the \ngetheaders\n message will include as many as 2,000 block headers.\n\n\n{% endautocrossref %}\n\n\nHeaders\n\n\nThe \nheaders\n message sends block headers to a node which\npreviously requested certain headers with a \ngetheaders\n message. A headers\nmessage can be empty.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nVaries\n\n\ncount\n\n\ncompactSize uint\n\n\nNumber of block headers up to a maximum of 2,000.  Note: headers-first sync assumes the sending node will send the maximum number of headers whenever possible.\n\n\n\n\n\n\nVaries\n\n\nheaders\n\n\nblock_header\n\n\nBlock headers: each 80-byte block header is in the format described in the \nblock headers section\n with an additional 0x00 suffixed.  This 0x00 is called the transaction count, but because the headers message doesn't include any transactions, the transaction count is always zero.\n\n\n\n\n\n\n\n\nThe following annotated hexdump shows a \nheaders\n message.  (The message\nheader has been omitted.)\n\n\n01 ................................. Header count: 1\n\n02000000 ........................... Block version: 2\nb6ff0b1b1680a2862a30ca44d346d9e8\n910d334beb48ca0c0000000000000000 ... Hash of previous block's header\n9d10aa52ee949386ca9385695f04ede2\n70dda20810decd12bc9b048aaab31471 ... Merkle root\n24d95a54 ........................... Unix time: 1415239972\n30c31b18 ........................... Target (bits)\nfe9f0864 ........................... Nonce\n\n00 ................................. Transaction count (0x00)\n\n\n\n\nInv\n\n\nThe \ninv\n message (inventory message) transmits one or more inventories of\nobjects known to the transmitting peer.  It can be sent unsolicited to\nannounce new transactions or blocks, or it can be sent in reply to a\n\ngetblocks\n message or \nmempool\n message.\n\n\nThe receiving peer can compare the inventories from an \ninv\n message\nagainst the inventories it has already seen, and then use a follow-up\nmessage to request unseen objects.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nVaries\n\n\ncount\n\n\ncompactSize uint\n\n\nThe number of inventory entries.\n\n\n\n\n\n\nVaries\n\n\ninventory\n\n\ninventory\n\n\nOne or more inventory entries up to a maximum of 50,000 entries.\n\n\n\n\n\n\n\n\nThe following annotated hexdump shows an \ninv\n message with two\ninventory entries.  (The message header has been omitted.)\n\n\n02 ................................. Count: 2\n\n01000000 ........................... Type: MSG_TX\nde55ffd709ac1f5dc509a0925d0b1fc4\n42ca034f224732e429081da1b621f55a ... Hash (TXID)\n\n01000000 ........................... Type: MSG_TX\n91d36d997037e08018262978766f24b8\na055aaf1d872e94ae85e9817b2c68dc7 ... Hash (TXID)\n\n\n\n\nMemPool\n\n\nThe \nmempool\n message requests the TXIDs of transactions that the\nreceiving node has verified as valid but which have not yet appeared in\na block. That is, transactions which are in the receiving node's memory\npool. The response to the \nmempool\n message is one or more \ninv\n\nmessages containing the TXIDs in the usual inventory format.\n\n\nSending the \nmempool\n message is mostly useful when a program first\nconnects to the network. Full nodes can use it to quickly gather most or\nall of the unconfirmed transactions available on the network; this is\nespecially useful for miners trying to gather transactions for their\ntransaction fees. SPV clients can set a filter before sending a\n\nmempool\n to only receive transactions that match that filter; this\nallows a recently-started client to get most or all unconfirmed\ntransactions related to its wallet.\n\n\nThe \ninv\n response to the \nmempool\n message is, at best, one node's\nview of the network---not a complete list of unconfirmed transactions\non the network. Here are some additional reasons the list might not\nbe complete:\n\n\n\n\n\n\nBefore Bitcoin Core 0.9.0, the response to the \nmempool\n message was\n  only one \ninv\n message. An \ninv\n message is limited to 50,000\n  inventories, so a node with a memory pool larger than 50,000 entries\n  would not send everything.  Later versions of Bitcoin Core send as\n  many \ninv\n messages as needed to reference its complete memory pool.\n\n\n\n\n\n\nThe \nmempool\n message is not currently fully compatible with the\n  \nfilterload\n message's \nBLOOM_UPDATE_ALL\n and\n  \nBLOOM_UPDATE_P2PUBKEY_ONLY\n flags. Mempool transactions are not\n  sorted like in-block transactions, so a transaction (tx2) spending an\n  output can appear before the transaction (tx1) containing that output,\n  which means the automatic filter update mechanism won't operate until\n  the second-appearing transaction (tx1) is seen---missing the\n  first-appearing transaction (tx2). It has been proposed in [Bitcoin\n  Core issue #2381][] that the transactions should be sorted before\n  being processed by the filter.\n\n\n\n\n\n\nThere is no payload in a \nmempool\n message.  See the [message header\nsection][section message header] for an example of a message without a payload.\n\n\nMerkleBlock\n\n\nThe \nmerkleblock\n message is a reply to a \ngetdata\n message which\nrequested a block using the inventory type \nMSG_MERKLEBLOCK\n.  It is\nonly part of the reply: if any matching transactions are found, they will\nbe sent separately as \ntx\n messages.\n\n\nIf a filter has been previously set with the \nfilterload\n message, the\n\nmerkleblock\n message will contain the TXIDs of any transactions in the\nrequested block that matched the filter, as well as any parts of the\nblock's merkle tree necessary to connect those transactions to the\nblock header's merkle root. The message also contains a complete copy\nof the block header to allow the client to hash it and confirm its\nproof of work.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n80\n\n\nblock header\n\n\nblock_header\n\n\nThe block header in the format described in the \nblock header section\n.\n\n\n\n\n\n\n4\n\n\ntransaction count\n\n\nuint32_t\n\n\nThe number of transactions in the block (including ones that don't match the filter).\n\n\n\n\n\n\nVaries\n\n\nhash count\n\n\ncompactSize uint\n\n\nThe number of hashes in the following field.\n\n\n\n\n\n\nVaries\n\n\nhashes\n\n\nchar[32]\n\n\nOne or more hashes of both transactions and merkle nodes in internal byte order.  Each hash is 32 bytes.\n\n\n\n\n\n\nVaries\n\n\nflag byte count\n\n\ncompactSize uint\n\n\nThe number of flag bytes in the following field.\n\n\n\n\n\n\nVaries\n\n\nflags\n\n\nbyte[]\n\n\nA sequence of bits packed eight in a byte with the least significant bit first.  May be padded to the nearest byte boundary but must not contain any more bits than that.  Used to assign the hashes to particular nodes in the merkle tree as described below.\n\n\n\n\n\n\n\n\nThe annotated hexdump below shows a \nmerkleblock\n message which\ncorresponds to the examples below.  (The message header has been\nomitted.)\n\n\n01000000 ........................... Block version: 1\n82bb869cf3a793432a66e826e05a6fc3\n7469f8efb7421dc88067010000000000 ... Hash of previous block's header\n7f16c5962e8bd963659c793ce370d95f\n093bc7e367117b3c30c1f8fdd0d97287 ... Merkle root\n76381b4d ........................... Time: 1293629558\n4c86041b ........................... nBits: 0x04864c * 256**(0x1b-3)\n554b8529 ........................... Nonce\n\n07000000 ........................... Transaction count: 7\n04 ................................. Hash count: 4\n\n3612262624047ee87660be1a707519a4\n43b1c1ce3d248cbfc6c15870f6c5daa2 ... Hash #1\n019f5b01d4195ecbc9398fbf3c3b1fa9\nbb3183301d7a1fb3bd174fcfa40a2b65 ... Hash #2\n41ed70551dd7e841883ab8f0b16bf041\n76b7d1480e4f0af9f3d4c3595768d068 ... Hash #3\n20d2a7bc994987302e5b1ac80fc425fe\n25f8b63169ea78e68fbaaefa59379bbf ... Hash #4\n\n01 ................................. Flag bytes: 1\n1d ................................. Flags: 1 0 1 1 1 0 0 0\n\n\n\n\nNote: when fully decoded, the above \nmerkleblock\n message provided the\nTXID for a single transaction that matched the filter. In the network\ntraffic dump this output was taken from, the full transaction belonging\nto that TXID was sent immediately after the \nmerkleblock\n message as\na \ntx\n message.\n\n\nParsing A MerkleBlock Message\n\n\nAs seen in the annotated hexdump above, the \nmerkleblock\n message\nprovides three special data types: a transaction count, a list of\nhashes, and a list of one-bit flags.\n\n\nYou can use the transaction count to construct an empty merkle tree.\nWe'll call each entry in the tree a node; on the bottom are TXID\nnodes---the hashes for these nodes are TXIDs; the remaining nodes\n(including the merkle root) are non-TXID nodes---they may actually have\nthe same hash as a TXID, but we treat them differently.\n\n\n\n\nKeep the hashes and flags in the order they appear in the \nmerkleblock\n\nmessage. When we say \"next flag\" or \"next hash\", we mean the next flag\nor hash on the list, even if it's the first one we've used so far.\n\n\nStart with the merkle root node and the first flag. The table below\ndescribes how to evaluate a flag based on whether the node being\nprocessed is a TXID node or a non-TXID node. Once you apply a flag to a\nnode, never apply another flag to that same node or reuse that same\nflag again.\n\n\n\n\n\n\n\n\nFlag\n\n\nTXID Node\n\n\nNon-TXID Node\n\n\n\n\n\n\n\n\n\n\n0\n\n\nUse the next hash as this node's TXID, but this transaction didn't match the filter.\n\n\nUse the next hash as this node's hash.  Don't process any descendant nodes.\n\n\n\n\n\n\n1\n\n\nUse the next hash as this node's TXID, and mark this transaction as matching the filter.\n\n\nThe hash needs to be computed.  Process the left child node to get its hash; process the right child node to get its hash; then concatenate the two hashes as 64 raw bytes and hash them to get this node's hash.\n\n\n\n\n\n\n\n\nAny time you begin processing a node for the first time, evaluate the next\nflag. Never use a flag at any other time.\n\n\nWhen processing a child node, you may need to process its children (the\ngrandchildren of the original node) or further-descended nodes before\nreturning to the parent node. This is expected---keep processing depth\nfirst until you reach a TXID node or a non-TXID node with a flag of 0.\n\n\nAfter you process a TXID node or a non-TXID node with a flag of 0, stop\nprocessing flags and begin to ascend the tree. As you ascend, compute\nthe hash of any nodes for which you now have both child hashes or for\nwhich you now have the sole child hash. See the [merkle tree\nsection][section merkle trees] for hashing instructions. If you reach a\nnode where only the left hash is known, descend into its right child (if\npresent) and further descendants as necessary.\n\n\nHowever, if you find a node whose left and right children both have the\nsame hash, fail.  This is related to CVE-2012-2459.\n\n\nContinue descending and ascending until you have enough information to\nobtain the hash of the merkle root node. If you run out of flags or\nhashes before that condition is reached, fail. Then perform the\nfollowing checks (order doesn't matter):\n\n\n\n\n\n\nFail if there are unused hashes in the hashes list.\n\n\n\n\n\n\nFail if there are unused flag bits---except for the minimum number of\n  bits necessary to pad up to the next full byte.\n\n\n\n\n\n\nFail if the hash of the merkle root node is not identical to the\n  merkle root in the block header.\n\n\n\n\n\n\nFail if the block header is invalid. Remember to ensure that the hash\n  of the header is less than or equal to the target threshold encoded by\n  the nBits header field. Your program should also, of course, attempt\n  to ensure the header belongs to the best block chain and that the user\n  knows how many confirmations this block has.\n\n\n\n\n\n\nFor a detailed example of parsing a \nmerkleblock\n message, please see\nthe corresponding [merkle block examples section][section merkleblock\nexample].\n\n\nCreating A MerkleBlock Message\n\n\nIt's easier to understand how to create a \nmerkleblock\n message after\nyou understand how to parse an already-created message, so we recommend\nyou read the parsing section above first.\n\n\nCreate a complete merkle tree with TXIDs on the bottom row and all the\nother hashes calculated up to the merkle root on the top row. For each\ntransaction that matches the filter, track its TXID node and all of its\nancestor nodes.\n\n\n\n\nStart processing the tree with the merkle root node. The table below\ndescribes how to process both TXID nodes and non-TXID nodes based on\nwhether the node is a match, a match ancestor, or neither a match nor a\nmatch ancestor.\n\n\n\n\n\n\n\n\n\n\nTXID Node\n\n\nNon-TXID Node\n\n\n\n\n\n\n\n\n\n\nNeither Match Nor Match Ancestor\n\n\nAppend a 0 to the flag list; append this node's TXID to the hash list.\n\n\nAppend a 0 to the flag list; append this node's hash to the hash list.  Do not descend into its child nodes.\n\n\n\n\n\n\nMatch Or Match Ancestor\n\n\nAppend a 1 to the flag list; append this node's TXID to the hash list.\n\n\nAppend a 1 to the flag list; process the left child node.  Then, if the node has a right child, process the right child.  Do not append a hash to the hash list for this node.\n\n\n\n\n\n\n\n\nAny time you begin processing a node for the first time, a flag should be\nappended to the flag list. Never put a flag on the list at any other\ntime, except when processing is complete to pad out the flag list to a\nbyte boundary.\n\n\nWhen processing a child node, you may need to process its children (the\ngrandchildren of the original node) or further-descended nodes before\nreturning to the parent node. This is expected---keep processing depth\nfirst until you reach a TXID node or a node which is neither a TXID nor\na match ancestor.\n\n\nAfter you process a TXID node or a node which is neither a TXID nor a\nmatch ancestor, stop processing and begin to ascend the tree until you\nfind a node with a right child you haven't processed yet. Descend into\nthat right child and process it.\n\n\nAfter you fully process the merkle root node according to the\ninstructions in the table above, processing is complete.  Pad your flag\nlist to a byte boundary and construct the \nmerkleblock\n message using the\ntemplate near the beginning of this subsection.\n\n\nNotFound\n\n\nThe \nnotfound\n message is a reply to a \ngetdata\n message which\nrequested an object the receiving node does not have available for\nrelay. (Nodes are not expected to relay historic transactions which\nare no longer in the memory pool or relay set. Nodes may also have\npruned spent transactions from older blocks, making them unable to\nsend those blocks.)\n\n\nThe format and maximum size limitations of the \nnotfound\n message are\nidentical to the \ninv\n message; only the message header differs.\n\n\nTx\n\n\nThe \ntx\n message transmits a single transaction in the raw transaction\nformat. It can be sent in a variety of situations;\n\n\n\n\n\n\nTransaction Response:\n Bitcoin Core and BitcoinJ will send it in\n  response to a \ngetdata\n message that requests the transaction with an\n  inventory type of \nMSG_TX\n.\n\n\n\n\n\n\nMerkleBlock Response:\n Bitcoin Core will send it in response to a\n  \ngetdata\n message that requests a merkle block with an inventory type\n  of \nMSG_MERKLEBLOCK\n. (This is in addition to sending a \nmerkleblock\n\n  message.) Each \ntx\n message in this case provides a matched\n  transaction from that block.\n\n\n\n\n\n\nUnsolicited:\n BitcoinJ will send a \ntx\n message unsolicited for\n  transactions it originates.\n\n\n\n\n\n\nFor an example hexdump of the raw transaction format, see the \nraw\ntransaction section\n.\n\n\nControl Messages\n\n\nThe following network messages all help control the connection between\ntwo peers or allow them to advise each other about the rest of the\nnetwork.\n\n\n\n\nNote that almost none of the control messages are authenticated in any\nway, meaning they can contain incorrect or intentionally harmful\ninformation. In addition, this section does not yet cover P2P protocol\noperation over the Tor network; if you would like to contribute\ninformation about Tor, please open an issue.\n\n\nAddr\n\n\nThe \naddr\n (IP address) message relays connection information\nfor peers on the network. Each peer which wants to accept incoming\nconnections creates an \naddr\n message providing its connection\ninformation and then sends that message to its peers unsolicited. Some\nof its peers send that information to their peers (also unsolicited),\nsome of which further distribute it, allowing decentralized peer\ndiscovery for any program already on the network.\n\n\nAn \naddr\n message may also be sent in response to a \ngetaddr\n message.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nVaries\n\n\nIP address count\n\n\ncompactSize uint\n\n\nThe number of IP address entries up to a maximum of 1,000.\n\n\n\n\n\n\nVaries\n\n\nIP addresses\n\n\nnetwork IP address\n\n\nIP address entries.  See the table below for the format of a Bitcoin network IP address.\n\n\n\n\n\n\n\n\nEach encapsulated network IP address currently uses the following structure:\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\ntime\n\n\nuint32\n\n\nAdded in protocol version 31402.\n \nA time in Unix epoch time format.  Nodes advertising their own IP address set this to the current time.  Nodes advertising IP addresses they've connected to set this to the last time they connected to that node.  Other nodes just relaying the IP address should not change the time.  Nodes can use the time field to avoid relaying old \naddr\n messages.  \nMalicious nodes may change times or even set them in the future.\n\n\n\n\n\n\n8\n\n\nservices\n\n\nuint64_t\n\n\nThe services the node advertised in its \nversion\n message.\n\n\n\n\n\n\n16\n\n\nIP address\n\n\nchar\n\n\nIPv6 address in \nbig endian byte order\n. IPv4 addresses can be provided as IPv4-mapped IPv6 addresses\n\n\n\n\n\n\n2\n\n\nport\n\n\nuint16_t\n\n\nPort number in \nbig endian byte order\n.  Note that Bitcoin Core will only connect to nodes with non-standard port numbers as a last resort for finding peers.  This is to prevent anyone from trying to use the network to disrupt non-Bitcoin services that run on other ports.\n\n\n\n\n\n\n\n\nThe following annotated hexdump shows part of an \naddr\n message. (The\nmessage header has been omitted and the actual IP address has been\nreplaced with a RFC5737 reserved IP address.)\n\n\nfde803 ............................. Address count: 1000\n\nd91f4854 ........................... Epoch time: 1414012889\n0100000000000000 ................... Service bits: 01 (network node)\n00000000000000000000ffffc0000233 ... IP Address: ::ffff:192.0.2.51\n208d ............................... Port: 8333\n\n[...] .............................. (999 more addresses omitted)\n\n\n\n\nFeeFilter\n\n\nThe \nfeefilter\n message is a request to the receiving peer to not relay any\ntransaction inv messages to the sending peer where the fee rate for the\ntransaction is below the fee rate specified in the feefilter message.\n\n\nfeefilter\n was introduced in Bitcoin Core 0.13.0 following the introduction\nof mempool limiting in Bitcoin Core 0.12.0. Mempool limiting provides protection against\nattacks and spam transactions that have low fee rates and are unlikely to be\nincluded in mined blocks. The \nfeefilter\n messages allows a node to inform its\npeers that it will not accept transactions below a specified fee rate into\nits mempool, and therefore that the peers can skip relaying inv messages for\ntransactions below that fee rate to that node.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n8\n\n\nfeerate\n\n\nuint64_t\n\n\nThe fee rate (in satoshis per kilobyte) below which transactions should not be relayed to this peer.\n\n\n\n\n\n\n\n\nThe receiving peer may choose to ignore the message and not filter transaction\ninv messages.\n\n\nThe fee filter is additive with bloom filters. If an SPV client loads a bloom\nfilter and sends a feefilter message, transactions should only be relayed if\nthey pass both filters.\n\n\nNote however that feefilter has no effect on block propagation or responses to\ngetdata messages. For example, if a node requests a merkleblock from its peer\nby sending a getdata message with inv type MSG_FILTERED_BLOCK and it has\npreviously sent a feefilter to that peer, the peer should respond with a\nmerkleblock containing \nall\n the transactions matching the bloom filter, even\nif they are below the feefilter fee rate.\n\n\ninv messages generated from a mempool message are subject to a fee filter if it exists.\n\n\nThe annotated hexdump below shows a \nfeefilter\n message. (The message\nheader has been omitted.)\n\n\n7cbd000000000000 ... satoshis per kilobyte: 48,508\n\n\n\n\nFilterAdd\n\n\nThe \nfilteradd\n message tells the receiving peer to add a single element to\na previously-set bloom filter, such as a new public key. The element is\nsent directly to the receiving peer; the peer then uses the parameters set\nin the \nfilterload\n message to add the element to the bloom filter.\n\n\nBecause the element is sent directly to the receiving peer, there is no\nobfuscation of the element and none of the plausible-deniability privacy\nprovided by the bloom filter. Clients that want to maintain greater\nprivacy should recalculate the bloom filter themselves and send a new\n\nfilterload\n message with the recalculated bloom filter.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nVaries\n\n\nelement bytes\n\n\ncompactSize uint\n\n\nThe number of bytes in the following element field.\n\n\n\n\n\n\nVaries\n\n\nelement\n\n\nuint8_t[]\n\n\nThe element to add to the current filter.  Maximum of 520 bytes, which is the maximum size of an element which can be pushed onto the stack in a pubkey or signature script.  Elements must be sent in the byte order they would use when appearing in a raw transaction; for example, hashes should be sent in internal byte order.\n\n\n\n\n\n\n\n\nNote: a \nfilteradd\n message will not be accepted unless a filter was\npreviously set with the \nfilterload\n message.\n\n\nThe annotated hexdump below shows a \nfilteradd\n message adding a TXID.\n(The message header has been omitted.) This TXID appears in the same\nblock used for the example hexdump in the \nmerkleblock\n message; if that\n\nmerkleblock\n message is re-sent after sending this \nfilteradd\n message,\nsix hashes are returned instead of four.\n\n\n20 ................................. Element bytes: 32\nfdacf9b3eb077412e7a968d2e4f11b9a\n9dee312d666187ed77ee7d26af16cb0b ... Element (A TXID)\n\n\n\n\nFilterClear\n\n\nThe \nfilterclear\n message tells the receiving peer to remove a\npreviously-set bloom filter.  This also undoes the effect of setting the\nrelay field in the \nversion\n message to 0, allowing unfiltered access to\n\ninv\n messages announcing new transactions.\n\n\nBitcoin Core does not require a \nfilterclear\n message before a\nreplacement filter is loaded with \nfilterload\n.  It also doesn't require\na \nfilterload\n message before a \nfilterclear\n message.\n\n\nThere is no payload in a \nfilterclear\n message.  See the [message header\nsection][section message header] for an example of a message without a payload.\n\n\nFilterLoad\n\n\nThe \nfilterload\n message tells the receiving peer to filter all relayed\ntransactions and requested merkle blocks through the provided filter.\nThis allows clients to receive transactions relevant to their wallet\nplus a configurable rate of false positive transactions which can\nprovide plausible-deniability privacy.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nVaries\n\n\nnFilterBytes\n\n\ncompactSize uint\n\n\nNumber of bytes in the following filter bit field.\n\n\n\n\n\n\nVaries\n\n\nfilter\n\n\nuint8_t[]\n\n\nA bit field of arbitrary byte-aligned size. The maximum size is 36,000 bytes.\n\n\n\n\n\n\n4\n\n\nnHashFuncs\n\n\nuint32_t\n\n\nThe number of hash functions to use in this filter. The maximum value allowed in this field is 50.\n\n\n\n\n\n\n4\n\n\nnTweak\n\n\nuint32_t\n\n\nAn arbitrary value to add to the seed value in the hash function used by the bloom filter.\n\n\n\n\n\n\n1\n\n\nnFlags\n\n\nuint8_t\n\n\nA set of flags that control how outpoints corresponding to a matched pubkey script are added to the filter. See the table in the Updating A Bloom Filter subsection below.\n\n\n\n\n\n\n\n\nThe annotated hexdump below shows a \nfilterload\n message. (The message\nheader has been omitted.)  For an example of how this payload was\ncreated, see the filterload example.\n\n\n02 ......... Filter bytes: 2\nb50f ....... Filter: 1010 1101 1111 0000\n0b000000 ... nHashFuncs: 11\n00000000 ... nTweak: 0/none\n00 ......... nFlags: BLOOM_UPDATE_NONE\n\n\n\n\nInitializing A Bloom Filter\n\n\nFilters have two core parameters: the size of the bit field and the\nnumber of hash functions to run against each data element. The following\nformulas from BIP37 will allow you to automatically select appropriate\nvalues based on the number of elements you plan to insert into the\nfilter (\nn\n) and the false positive rate (\np\n) you desire to maintain\nplausible deniability.\n\n\n\n\n\n\nSize of the bit field in bytes (\nnFilterBytes\n), up to a maximum of\n  36,000: \n(-1 / log(2)**2 * n * log(p)) / 8\n\n\n\n\n\n\nHash functions to use (\nnHashFuncs\n), up to a maximum of 50:\n  \nnFilterBytes * 8 / n * log(2)\n\n\n\n\n\n\nNote that the filter matches parts of transactions (transaction\nelements), so the false positive rate is relative to the number of\nelements checked---not the number of transactions checked. Each normal\ntransaction has a minimum of four matchable elements (described in the\ncomparison subsection below), so a filter with a false-positive rate of\n1 percent will match about 4 percent of all transactions at a minimum.\n\n\nAccording to BIP37, the formulas and limits described above provide\nsupport for bloom filters containing 20,000 items with a false positive\nrate of less than 0.1 percent or 10,000 items with a false positive rate\nof less than 0.0001 percent.\n\n\nOnce the size of the bit field is known, the bit field should be\ninitialized as all zeroes.\n\n\nPopulating A Bloom Filter\n\n\nThe bloom filter is populated using between 1 and 50 unique hash\nfunctions (the number specified per filter by the \nnHashFuncs\n\nfield). Instead of using up to 50 different hash function\nimplementations, a single implementation is used with a unique seed\nvalue for each function.\n\n\nThe seed is \nnHashNum * 0xfba4c795 + nTweak\n as a \nuint32_t\n, where the values\nare:\n\n\n\n\n\n\nnHashNum\n is the sequence number for this hash\n  function, starting at 0 for the first hash iteration and increasing up\n  to the value of the \nnHashFuncs\n field (minus one) for the last hash\n  iteration.\n\n\n\n\n\n\n0xfba4c795\n is a constant optimized to create large differences in\n  the seed for different values of \nnHashNum\n.\n\n\n\n\n\n\nnTweak\n is a per-filter constant set by the client to require the use\n  of an arbitrary set of hash functions.\n\n\n\n\n\n\nIf the seed resulting from the formula above is larger than four bytes,\nit must be truncated to its four most significant bytes (for example,\n\n0x8967452301 \n 0xffffffff \u2192 0x67452301\n).\n\n\nThe actual hash function implementation used is the [32-bit Murmur3 hash\nfunction][murmur3].\n\n\n\n\nWarning:\n the Murmur3 hash function has separate 32-bit and 64-bit\nversions that produce different results for the same input.  Only the\n32-bit Murmur3 version is used with Bitcoin bloom filters.\n\n\nThe data to be hashed can be any transaction element which the bloom\nfilter can match. See the next subsection for the list of transaction\nelements checked against the filter. The largest element which can be\nmatched is a script data push of 520 bytes, so the data should never\nexceed 520 bytes.\n\n\nThe example below from Bitcoin Core [bloom.cpp][core bloom.cpp hash] combines\nall the steps above to create the hash function template. The seed is\nthe first parameter; the data to be hashed is the second parameter. The\nresult is a uint32_t modulo the size of the bit field in bits.\n\n\n{% highlight c++ %}\nMurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8)\n{% endhighlight %}\n\n\nEach data element to be added to the filter is hashed by \nnHashFuncs\n\nnumber of hash functions. Each time a hash function is run, the result\nwill be the index number (\nnIndex\n) of a bit in the bit field. That bit\nmust be set to 1. For example if the filter bit field was \n00000000\n and\nthe result is 5, the revised filter bit field is \n00000100\n (the first bit\nis bit 0).\n\n\nIt is expected that sometimes the same index number will be returned\nmore than once when populating the bit field; this does not affect the\nalgorithm---after a bit is set to 1, it is never changed back to 0.\n\n\nAfter all data elements have been added to the filter, each set of eight\nbits is converted into a little-endian byte. These bytes are the value\nof the \nfilter\n field.\n\n\nComparing Transaction Elements To A Bloom Filter\n\n\nTo compare an arbitrary data element against the bloom filter, it is\nhashed using the same parameters used to create the bloom filter.\nSpecifically, it is hashed \nnHashFuncs\n times, each time using the same\n\nnTweak\n provided in the filter, and the resulting output is modulo the\nsize of the bit field provided in the \nfilter\n field.  After each hash is\nperformed, the filter is checked to see if the bit at that indexed\nlocation is set.  For example if the result of a hash is \n5\n and the\nfilter is \n01001110\n, the bit is considered set.\n\n\nIf the result of every hash points to a set bit, the filter matches. If\nany of the results points to an unset bit, the filter does not match.\n\n\nThe following transaction elements are compared against bloom filters.\nAll elements will be hashed in the byte order used in blocks (for\nexample, TXIDs will be in internal byte order).\n\n\n\n\n\n\nTXIDs:\n the transaction's SHA256(SHA256()) hash.\n\n\n\n\n\n\nOutpoints:\n each 36-byte outpoint used this transaction's input\n  section is individually compared to the filter.\n\n\n\n\n\n\nSignature Script Data:\n each element pushed onto the stack by a\n  data-pushing opcode in a signature script from this transaction is\n  individually compared to the filter.  This includes data elements\n  present in P2SH redeem scripts when they are being spent.\n\n\n\n\n\n\nPubKey Script Data:\n each element pushed onto the the stack by a\n  data-pushing opcode in any pubkey script from this transaction is\n  individually compared to the filter. (If a pubkey script element\n  matches the filter, the filter will be immediately updated if the\n  \nBLOOM_UPDATE_ALL\n flag was set; if the pubkey script is in the P2PKH\n  format and matches the filter, the filter will be immediately updated\n  if the \nBLOOM_UPDATE_P2PUBKEY_ONLY\n flag was set. See the subsection\n  below for details.)\n\n\n\n\n\n\nThe following annotated hexdump of a transaction is from the [raw\ntransaction format section][raw transaction format]; the elements which\nwould be checked by the filter are emphasized in bold. Note that this\ntransaction's TXID (\n01000000017b1eab[...]\n) would also be checked,\nand that the outpoint TXID and index number below would be checked as a\nsingle 36-byte element.\n\n\n01000000 ................................... Version\n\n01 ......................................... Number of inputs\n|\n| \n7b1eabe0209b1fe794124575ef807057\n\n| \nc77ada2138ae4fa8d6c4de0398a14f3f\n ......... Outpoint TXID\n| \n00000000\n ................................. Outpoint index number\n|\n| 49 ....................................... Bytes in sig. script: 73\n| | 48 ..................................... Push 72 bytes as data\n| | | \n30450221008949f0cb400094ad2b5eb3\n\n| | | \n99d59d01c14d73d8fe6e96df1a7150de\n\n| | | \nb388ab8935022079656090d7f6bac4c9\n\n| | | \na94e0aad311a4268e082a725f8aeae05\n\n| | | \n73fb12ff866a5f01\n ..................... Secp256k1 signature\n|\n| ffffffff ................................. Sequence number: UINT32_MAX\n\n01 ......................................... Number of outputs\n| f0ca052a01000000 ......................... Satoshis (49.99990000 BTC)\n|\n| 19 ....................................... Bytes in pubkey script: 25\n| | 76 ..................................... OP_DUP\n| | a9 ..................................... OP_HASH160\n| | 14 ..................................... Push 20 bytes as data\n| | | \ncbc20a7664f2f69e5355aa427045bc15\n\n| | | \ne7c6c772\n ............................. PubKey hash\n| | 88 ..................................... OP_EQUALVERIFY\n| | ac ..................................... OP_CHECKSIG\n\n00000000 ................................... locktime: 0 (a block height)\n\n\n\n\nUpdating A Bloom Filter\n\n\nClients will often want to track inputs that spend outputs (outpoints)\nrelevant to their wallet, so the filterload field \nnFlags\n can be set to\nallow the filtering node to update the filter when a match is found.\nWhen the filtering node sees a pubkey script that pays a pubkey,\naddress, or other data element matching the filter, the filtering node\nimmediately updates the filter with the outpoint corresponding to that\npubkey script.\n\n\n\n\nIf an input later spends that outpoint, the filter will match it,\nallowing the filtering node to tell the client that one of its\ntransaction outputs has been spent.\n\n\nThe \nnFlags\n field has three allowed values:\n\n\n\n\n\n\n\n\nValue\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0\n\n\nBLOOM_UPDATE_NONE\n\n\nThe filtering node should not update the filter.\n\n\n\n\n\n\n1\n\n\nBLOOM_UPDATE_ALL\n\n\nIf the filter matches any data element in a pubkey script, the corresponding outpoint is added to the filter.\n\n\n\n\n\n\n2\n\n\nBLOOM_UPDATE_P2PUBKEY_ONLY\n\n\nIf the filter matches any data element in a pubkey script and that script is either a P2PKH or non-P2SH pay-to-multisig script, the corresponding outpoint is added to the filter.\n\n\n\n\n\n\n\n\nIn addition, because the filter size stays the same even though\nadditional elements are being added to it, the false positive rate\nincreases. Each false positive can result in another element being added\nto the filter, creating a feedback loop that can (after a certain point)\nmake the filter useless. For this reason, clients using automatic filter\nupdates need to monitor the actual false positive rate and send a new\nfilter when the rate gets too high.\n\n\n{% endautocrossref %}\n\n\nGetAddr\n\n\n{% include helpers/subhead-links.md %}\n\n\n{% autocrossref %}\n\n\nThe \ngetaddr\n message requests an \naddr\n message from the receiving\nnode, preferably one with lots of IP addresses of other receiving nodes.\nThe transmitting node can use those IP addresses to quickly update its\ndatabase of available nodes rather than waiting for unsolicited \naddr\n\nmessages to arrive over time.\n\n\nThere is no payload in a \ngetaddr\n message.  See the [message header\nsection][section message header] for an example of a message without a payload.\n\n\n{% endautocrossref %}\n\n\nPing\n\n\n{% include helpers/subhead-links.md %}\n\n\n{% autocrossref %}\n\n\nThe \nping\n message helps confirm that the receiving peer is still\nconnected. If a TCP/IP error is encountered when sending the \nping\n\nmessage (such as a connection timeout), the transmitting node can assume\nthat the receiving node is disconnected. The response to a \nping\n\nmessage is the \npong\n message.\n\n\nBefore protocol version 60000, the \nping\n message had no payload. As of\nprotocol version 60001 and all later versions, the message includes a\nsingle field, the nonce.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n8\n\n\nnonce\n\n\nuint64_t\n\n\nAdded in protocol version 60001 as described by BIP31.\n \nRandom nonce assigned to this \nping\n message.  The responding \npong\n message will include this nonce to identify the \nping\n message to which it is replying.\n\n\n\n\n\n\n\n\nThe annotated hexdump below shows a \nping\n message. (The message\nheader has been omitted.)\n\n\n{% highlight text %}\n0094102111e2af4d ... Nonce\n{% endhighlight %}\n\n\n{% endautocrossref %}\n\n\nPong\n\n\n{% include helpers/subhead-links.md %}\n\n\n{% autocrossref %}\n\n\nAdded in protocol version 60001 as described by BIP31.\n\n\nThe \npong\n message replies to a \nping\n message, proving to the pinging\nnode that the ponging node is still alive. Bitcoin Core will, by\ndefault, disconnect from any clients which have not responded to a\n\nping\n message within 20 minutes.\n\n\nTo allow nodes to keep track of latency, the \npong\n message sends back\nthe same nonce received in the \nping\n message it is replying to.\n\n\nThe format of the \npong\n message is identical to the \nping\n message;\nonly the message header differs.\n\n\n{% endautocrossref %}\n\n\nReject\n\n\n{% include helpers/subhead-links.md %}\n\n\n{% autocrossref %}\n\n\nAdded in protocol version 70002 as described by BIP61.\n\n\nThe \nreject\n message informs the receiving node that one of its previous\nmessages has been rejected.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nVaries\n\n\nmessage bytes\n\n\ncompactSize uint\n\n\nThe number of bytes in the following message field.\n\n\n\n\n\n\nVaries\n\n\nmessage\n\n\nstring\n\n\nThe type of message rejected as ASCII text \nwithout null padding\n.  For example: \"tx\", \"block\", or \"version\".\n\n\n\n\n\n\n1\n\n\ncode\n\n\nchar\n\n\nThe reject message code.  See the table below.\n\n\n\n\n\n\nVaries\n\n\nreason bytes\n\n\ncompactSize uint\n\n\nThe number of bytes in the following reason field.  May be 0x00 if a text reason isn't provided.\n\n\n\n\n\n\nVaries\n\n\nreason\n\n\nstring\n\n\nThe reason for the rejection in ASCII text.  This should not be displayed to the user; it is only for debugging purposes.\n\n\n\n\n\n\nVaries\n\n\nextra data\n\n\nvaries\n\n\nOptional additional data provided with the rejection.  For example, most rejections of \ntx\n messages or \nblock\n messages include the hash of the rejected transaction or block header.  See the code table below.\n\n\n\n\n\n\n\n\nThe following table lists message reject codes.  Codes are tied to the\ntype of message they reply to; for example there is a 0x10 reject code\nfor transactions and a 0x10 reject code for blocks.\n\n\n\n\n\n\n\n\n\n\n\nCode\n\n\nIn Reply To\n\n\nExtra Bytes\n\n\nExtra Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0x01\n\n\nany message\n\n\n0\n\n\nN/A\n\n\nMessage could not be decoded.  Be careful of \nreject\n message feedback loops where two peers each don't understand each other's \nreject\n messages and so keep sending them back and forth forever.\n\n\n\n\n\n\n0x10\n\n\nblock\n message\n\n\n32\n\n\nchar[32]\n\n\nBlock is invalid for some reason (invalid proof-of-work, invalid signature, etc).  Extra data may include the rejected block's header hash.\n\n\n\n\n\n\n0x10\n\n\ntx\n message\n\n\n32\n\n\nchar[32]\n\n\nTransaction is invalid for some reason (invalid signature, output value greater than input, etc.).  Extra data may include the rejected transaction's TXID.\n\n\n\n\n\n\n0x11\n\n\nblock\n message\n\n\n32\n\n\nchar[32]\n\n\nThe block uses a version that is no longer supported.  Extra data may include the rejected block's header hash.\n\n\n\n\n\n\n0x11\n\n\nversion\n message\n\n\n0\n\n\nN/A\n\n\nConnecting node is using a protocol version that the rejecting node considers obsolete and unsupported.\n\n\n\n\n\n\n0x12\n\n\ntx\n message\n\n\n32\n\n\nchar[32]\n\n\nDuplicate input spend (double spend): the rejected transaction spends the same input as a previously-received transaction.  Extra data may include the rejected transaction's TXID.\n\n\n\n\n\n\n0x12\n\n\nversion\n message\n\n\n0\n\n\nN/A\n\n\nMore than one \nversion\n message received in this connection.\n\n\n\n\n\n\n0x40\n\n\ntx\n message\n\n\n32\n\n\nchar[32]\n\n\nThe transaction will not be mined or relayed because the rejecting node considers it non-standard---a transaction type or version unknown by the server.  Extra data may include the rejected transaction's TXID.\n\n\n\n\n\n\n0x41\n\n\ntx\n message\n\n\n32\n\n\nchar[32]\n\n\nOne or more output amounts are below the dust threshold.  Extra data may include the rejected transaction's TXID.\n\n\n\n\n\n\n0x42\n\n\ntx\n message\n\n\n\n\nchar[32]\n\n\nThe transaction did not have a large enough fee or priority to be relayed or mined.  Extra data may include the rejected transaction's TXID.\n\n\n\n\n\n\n0x43\n\n\nblock\n message\n\n\n32\n\n\nchar[32]\n\n\nThe block belongs to a block chain which is not the same block chain as provided by a compiled-in checkpoint.  Extra data may include the rejected block's header hash.\n\n\n\n\n\n\n\n\nThe annotated hexdump below shows a \nreject\n message. (The message\nheader has been omitted.)\n\n\n{% highlight text %}\n02 ................................. Number of bytes in message: 2\n7478 ............................... Type of message rejected: tx\n12 ................................. Reject code: 0x12 (duplicate)\n15 ................................. Number of bytes in reason: 21\n6261642d74786e732d696e707574732d\n7370656e74 ......................... Reason: bad-txns-inputs-spent\n394715fcab51093be7bfca5a31005972\n947baf86a31017939575fb2354222821 ... TXID\n{% endhighlight %}\n\n\n{% endautocrossref %}\n\n\nSendHeaders\n\n\n{% include helpers/subhead-links.md %}\n\n\n{% autocrossref %}\n\n\nThe \nsendheaders\n message tells the receiving peer to send new block\nannouncements using a \nheaders\n message rather than an \ninv\n message.\n\n\nThere is no payload in a \nsendheaders\n message.  See the [message header\nsection][section message header] for an example of a message without a payload.\n\n\n{% endautocrossref %}\n\n\nVerAck\n\n\n{% include helpers/subhead-links.md %}\n\n\n{% autocrossref %}\n\n\nAdded in protocol version 209.\n\n\nThe \nverack\n message acknowledges a previously-received \nversion\n\nmessage, informing the connecting node that it can begin to send\nother messages. The \nverack\n message has no payload; for an example\nof a message with no payload, see the [message headers\nsection][section message header].\n\n\n{% endautocrossref %}\n\n\nVersion\n\n\n{% include helpers/subhead-links.md %}\n\n\n{% autocrossref %}\n\n\nThe \nversion\n message provides information about the transmitting node\nto the receiving node at the beginning of a connection. Until both peers\nhave exchanged \nversion\n messages, no other messages will be accepted.\n\n\nIf a \nversion\n message is accepted, the receiving node should send a\n\nverack\n message---but no node should send a \nverack\n message\nbefore initializing its half of the connection by first sending a\n\nversion\n message.\n\n\n\n\n\n\n\n\nBytes\n\n\nName\n\n\nData Type\n\n\nRequired/Optional\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n4\n\n\nversion\n\n\nint32_t\n\n\nRequired\n\n\nThe highest protocol version understood by the transmitting node.  See the [protocol version section][section protocol versions].\n\n\n\n\n\n\n8\n\n\nservices\n\n\nuint64_t\n\n\nRequired\n\n\nThe services supported by the transmitting node encoded as a bitfield.  See the list of service codes below.\n\n\n\n\n\n\n8\n\n\ntimestamp\n\n\nint64_t\n\n\nRequired\n\n\nThe current Unix epoch time according to the transmitting node's clock.  Because nodes will reject blocks with timestamps more than two hours in the future, this field can help other nodes to determine that their clock is wrong.\n\n\n\n\n\n\n8\n\n\naddr_recv services\n\n\nuint64_t\n\n\nRequired\n\n\nThe services supported by the receiving node as perceived by the transmitting node.  Same format as the 'services' field above. Bitcoin Core will attempt to provide accurate information.  BitcoinJ will, by default, always send 0.\n\n\n\n\n\n\n16\n\n\naddr_recv IP address\n\n\nchar\n\n\nRequired\n\n\nThe IPv6 address of the receiving node as perceived by the transmitting node in \nbig endian byte order\n. IPv4 addresses can be provided as [IPv4-mapped IPv6 addresses][]. Bitcoin Core will attempt to provide accurate information.  BitcoinJ will, by default, always return ::ffff:127.0.0.1\n\n\n\n\n\n\n2\n\n\naddr_recv port\n\n\nuint16_t\n\n\nRequired\n\n\nThe port number of the receiving node as perceived by the transmitting node in \nbig endian byte order\n.\n\n\n\n\n\n\n8\n\n\naddr_trans services\n\n\nuint64_t\n\n\nRequired\n\n\nAdded in protocol version 106.\n \nThe services supported by the transmitting node.  Should be identical to the 'services' field above.\n\n\n\n\n\n\n16\n\n\naddr_trans IP address\n\n\nchar\n\n\nRequired\n\n\nAdded in protocol version 106.\n \nThe IPv6 address of the transmitting node in \nbig endian byte order\n. IPv4 addresses can be provided as [IPv4-mapped IPv6 addresses][].  Set to ::ffff:127.0.0.1 if unknown.\n\n\n\n\n\n\n2\n\n\naddr_trans port\n\n\nuint16_t\n\n\nRequired\n\n\nAdded in protocol version 106.\n \nThe port number of the transmitting node in \nbig endian byte order\n.\n\n\n\n\n\n\n8\n\n\nnonce\n\n\nuint64_t\n\n\nRequired\n\n\nAdded in protocol version 106.\n \nA random nonce which can help a node detect a connection to itself.  If the nonce is 0, the nonce field is ignored.  If the nonce is anything else, a node should terminate the connection on receipt\n of a \nversion\n message with a nonce it previously sent.\n\n\n\n\n\n\nVaries\n\n\nuser_agent bytes\n\n\ncompactSize uint\n\n\nRequired\n\n\nAdded in protocol version 106.\n \nNumber of bytes in following user_agent field.  If 0x00, no user agent field is sent.\n\n\n\n\n\n\nVaries\n\n\nuser_agent\n\n\nstring\n\n\nRequired if user_agent bytes \n 0\n\n\nAdded in protocol version 106. Renamed in protocol version 60000.\n \nUser agent as defined by BIP14. Previously called subVer.\n\n\n\n\n\n\n4\n\n\nstart_height\n\n\nint32_t\n\n\nRequired\n\n\nAdded in protocol version 209.\n \nThe height of the transmitting node's best block chain or, in the case of an SPV client, best block header chain.\n\n\n\n\n\n\n1\n\n\nrelay\n\n\nbool\n\n\nOptional\n\n\nAdded in protocol version 70001 as described by BIP37.\n \nTransaction relay flag.  If 0x00, no \ninv\n messages or \ntx\n messages announcing new transactions should be sent to this client until it sends a \nfilterload\n message or \nfilterclear\n message.  If the relay field is not present or is set to 0x01, this node wants \ninv\n messages and \ntx\n messages announcing new transactions.\n\n\n\n\n\n\n\n\nThe following service identifiers have been assigned.\n\n\n\n\n\n\n\n\nValue\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0x00\n\n\nUnnamed\n\n\nThis node is not a full node.  It may not be able to provide any data except for the transactions it originates.\n\n\n\n\n\n\n0x01\n\n\nNODE_NETWORK\n\n\nThis is a full node and can be asked for full blocks.  It should implement all protocol features available in its self-reported protocol version.\n\n\n\n\n\n\n\n\nThe following annotated hexdump shows a \nversion\n message. (The\nmessage header has been omitted and the actual IP addresses have been\nreplaced with [RFC5737][] reserved IP addresses.)\n\n\n{% highlight text %}\n72110100 ........................... Protocol version: 70002\n0100000000000000 ................... Services: NODE_NETWORK\nbc8f5e5400000000 ................... Epoch time: 1415483324\n\n\n0100000000000000 ................... Receiving node's services\n00000000000000000000ffffc61b6409 ... Receiving node's IPv6 address\n208d ............................... Receiving node's port number\n\n\n0100000000000000 ................... Transmitting node's services\n00000000000000000000ffffcb0071c0 ... Transmitting node's IPv6 address\n208d ............................... Transmitting node's port number\n\n\n128035cbc97953f8 ................... Nonce\n\n\n0f ................................. Bytes in user agent string: 15\n2f5361746f7368693a302e392e332f ..... User agent: /Satoshi:0.9.3/\n\n\ncf050500 ........................... Start height: 329167\n01 ................................. Relay flag: true\n{% endhighlight %}\n\n\n{% endautocrossref %}", 
            "title": "P2P Network"
        }, 
        {
            "location": "/p2p/#constants-and-defaults", 
            "text": "The following constants and defaults are taken from Bitcoin Core's\nchainparams.cpp source code file.     Network  Default Port  Start String  Max nBits      Mainnet  8333  0xf9beb4d9  0x1d00ffff    Testnet  18333  0x0b110907  0x1d00ffff    Regtest  18444  0xfabfb5da  0x207fffff     Note: the testnet start string and nBits above are for testnet3; the\noriginal testnet used a different string and higher (less difficult)\nnBits.  Command line parameters can change what port a node listens on (see -help ). Start strings are hardcoded constants that appear at the start\nof all messages sent on the Bitcoin network; they may also appear in\ndata files such as Bitcoin Core's block database.  The nBits displayed\nabove are in big-endian order; they're sent over the network in\nlittle-endian order.  Bitcoin Core's chainparams.cpp also includes\nother constants useful to programs, such as the hash of the genesis\nblocks for the different networks.", 
            "title": "Constants And Defaults"
        }, 
        {
            "location": "/p2p/#protocol-versions", 
            "text": "The table below lists some notable versions of the P2P network protocol,\nwith the most recent versions listed first. (If you know of a protocol\nversion that implemented a major change but which is not listed here,\nplease open an issue.)  As of Bitcoin Core 2.1.0.4, the most recent protocol version is 60014.     Version  Initial Release  Major Changes      60014  Pinkcoin Core v2.1.0.3  Hardforking Network Attack Bug-fix ( Details )", 
            "title": "Protocol Versions"
        }, 
        {
            "location": "/p2p/#message-headers", 
            "text": "All messages in the network protocol use the same container format,\nwhich provides a required multi-field message header and an optional payload.\nThe message header format is:     Bytes  Name  Data Type  Description      4  start string  char[4]  Magic bytes indicating the originating network; used to seek to next message when stream state is unknown.    12  command name  char[12]  ASCII string which identifies what message type is contained in the payload.  Followed by nulls (0x00) to pad out byte count; for example:  version\\0\\0\\0\\0\\0 .    4  payload size  uint32_t  Number of bytes in payload.  The current maximum number of bytes ( MAX_SIZE ) allowed in the payload by Bitcoin Core is 32 MiB---messages with a payload size larger than this will be dropped or rejected.    4  checksum  char[4]  Added in protocol version 209.   First 4 bytes of SHA256(SHA256(payload)) in internal byte order.  If payload is empty, as in  verack  and  getaddr  messages, the checksum is always 0x5df6e0e2 (SHA256(SHA256(\\ ))).     The following example is an annotated hex dump of a mainnet message\nheader from a  verack  message which has no payload.  f9beb4d9 ................... Start string: Mainnet\n76657261636b000000000000 ... Command name: verack + null padding\n00000000 ................... Byte count: 0\n5df6e0e2 ................... Checksum: SHA256(SHA256( empty ))", 
            "title": "Message Headers"
        }, 
        {
            "location": "/p2p/#data-messages", 
            "text": "The following network messages all request or provide data related to\ntransactions and blocks.   Many of the data messages use\ninventories as unique identifiers\nfor transactions and blocks.  Inventories have a simple 36-byte\nstructure:     Bytes  Name  Data Type  Description      4  type identifier  uint32_t  The type of object which was hashed.  See list of type identifiers below.    32  hash  char[32]  SHA256(SHA256()) hash of the object in internal byte order.     The currently-available type identifiers are:     Type Identifier  Name  Description      1  MSG_TX  The hash is a TXID.    2  MSG_BLOCK  The hash is of a block header.    3  MSG_FILTERED_BLOCK  The hash is of a block header; identical to  MSG_BLOCK . When used in a  getdata  message, this indicates the response should be a  merkleblock  message rather than a  block  message (but this only works if a bloom filter was previously configured).   Only for use in  getdata  messages.     Type identifier zero and type identifiers greater than three are reserved\nfor future implementations. Bitcoin Core ignores all inventories with\none of these unknown types.", 
            "title": "Data Messages"
        }, 
        {
            "location": "/p2p/#block", 
            "text": "The  block  message transmits a single serialized block in the format\ndescribed in the  serialized blocks section .\nSee that section for an example hexdump.  It can be sent for two\ndifferent reasons:    GetData Response:  Nodes will always send it in response to a\n    getdata  message that requests the block with an inventory\n   type of  MSG_BLOCK  (provided the node has that block available for\n   relay).    Unsolicited:  Some miners will send unsolicited  block  messages\n   broadcasting their newly-mined blocks to all of their peers. Many\n   mining pools do the same thing, although some may be misconfigured to\n   send the block from multiple nodes, possibly sending the same block\n   to some peers more than once.", 
            "title": "Block"
        }, 
        {
            "location": "/p2p/#getblocks", 
            "text": "The  getblocks  message requests an  inv  message that provides block\nheader hashes starting from a particular point in the block chain. It\nallows a peer which has been disconnected or started for the first time\nto get the data it needs to request the blocks it hasn't seen.  Peers which have been disconnected may have stale blocks in their\nlocally-stored block chain, so the  getblocks  message allows the\nrequesting peer to provide the receiving peer with multiple header\nhashes at various heights on their local chain. This allows the\nreceiving peer to find, within that list, the last header hash they had\nin common and reply with all subsequent header hashes.  Note: the receiving peer itself may respond with an  inv  message\ncontaining header hashes of stale blocks.  It is up to the requesting\npeer to poll all of its peers to find the best block chain.  If the receiving peer does not find a common header hash within the\nlist, it will assume the last common block was the genesis block (block\nzero), so it will reply with in  inv  message containing header hashes\nstarting with block one (the first block after the genesis block).     Bytes  Name  Data Type  Description      4  version  uint32_t  The protocol version number; the same as sent in the  version  message.    Varies  hash count  compactSize uint  The number of header hashes provided not including the stop hash.  There is no limit except that the byte size of the entire message must be below the  MAX_SIZE  limit; typically from 1 to 200 hashes are sent.    Varies  block header hashes  char[32]  One or more block header hashes (32 bytes each) in internal byte order.  Hashes should be provided in reverse order of block height, so highest-height hashes are listed first and lowest-height hashes are listed last.    32  stop hash  char[32]  The header hash of the last header hash being requested; set to all zeroes to request an  inv  message with all subsequent header hashes (a maximum of 500 will be sent as a reply to this message; if you need more than 500, you will need to send another  getblocks  message with a higher-height header hash as the first entry in block header hash field).     The following annotated hexdump shows a  getblocks  message.  (The\nmessage header has been omitted.)  71110100 ........................... Protocol version: 70001\n02 ................................. Hash count: 2\n\nd39f608a7775b537729884d4e6633bb2\n105e55a16a14d31b0000000000000000 ... Hash #1\n\n5c3e6403d40837110a2e8afb602b1c01\n714bda7ce23bea0a0000000000000000 ... Hash #2\n\n00000000000000000000000000000000\n00000000000000000000000000000000 ... Stop hash", 
            "title": "GetBlocks"
        }, 
        {
            "location": "/p2p/#getdata", 
            "text": "The  getdata  message requests one or more data objects from another\nnode. The objects are requested by an inventory, which the requesting\nnode typically received previously by way of an  inv  message.  The response to a  getdata  message can be a  tx  message,  block \nmessage,  merkleblock  message, or  notfound  message.  This message cannot be used to request arbitrary data, such as historic\ntransactions no longer in the memory pool or relay set. Full nodes may\nnot even be able to provide older blocks if they've pruned old\ntransactions from their block database. For this reason, the  getdata \nmessage should usually only be used to request data from a node which\npreviously advertised it had that data by sending an  inv  message.  The format and maximum size limitations of the  getdata  message are\nidentical to the  inv  message; only the message header differs.", 
            "title": "GetData"
        }, 
        {
            "location": "/p2p/#getheaders", 
            "text": "The  getheaders  message requests a  headers  message that provides block headers\nstarting from a particular point in the block chain. It allows a\npeer which has been disconnected or started for the first time to get\nthe headers it hasn\u2019t seen yet.  The  getheaders  message is nearly identical to the  getblocks  message,\nwith one minor difference: the  inv  reply to the  getblocks  message\nwill include no more than 500 block header hashes; the  headers  reply\nto the  getheaders  message will include as many as 2,000 block headers.  {% endautocrossref %}", 
            "title": "GetHeaders"
        }, 
        {
            "location": "/p2p/#headers", 
            "text": "The  headers  message sends block headers to a node which\npreviously requested certain headers with a  getheaders  message. A headers\nmessage can be empty.     Bytes  Name  Data Type  Description      Varies  count  compactSize uint  Number of block headers up to a maximum of 2,000.  Note: headers-first sync assumes the sending node will send the maximum number of headers whenever possible.    Varies  headers  block_header  Block headers: each 80-byte block header is in the format described in the  block headers section  with an additional 0x00 suffixed.  This 0x00 is called the transaction count, but because the headers message doesn't include any transactions, the transaction count is always zero.     The following annotated hexdump shows a  headers  message.  (The message\nheader has been omitted.)  01 ................................. Header count: 1\n\n02000000 ........................... Block version: 2\nb6ff0b1b1680a2862a30ca44d346d9e8\n910d334beb48ca0c0000000000000000 ... Hash of previous block's header\n9d10aa52ee949386ca9385695f04ede2\n70dda20810decd12bc9b048aaab31471 ... Merkle root\n24d95a54 ........................... Unix time: 1415239972\n30c31b18 ........................... Target (bits)\nfe9f0864 ........................... Nonce\n\n00 ................................. Transaction count (0x00)", 
            "title": "Headers"
        }, 
        {
            "location": "/p2p/#inv", 
            "text": "The  inv  message (inventory message) transmits one or more inventories of\nobjects known to the transmitting peer.  It can be sent unsolicited to\nannounce new transactions or blocks, or it can be sent in reply to a getblocks  message or  mempool  message.  The receiving peer can compare the inventories from an  inv  message\nagainst the inventories it has already seen, and then use a follow-up\nmessage to request unseen objects.     Bytes  Name  Data Type  Description      Varies  count  compactSize uint  The number of inventory entries.    Varies  inventory  inventory  One or more inventory entries up to a maximum of 50,000 entries.     The following annotated hexdump shows an  inv  message with two\ninventory entries.  (The message header has been omitted.)  02 ................................. Count: 2\n\n01000000 ........................... Type: MSG_TX\nde55ffd709ac1f5dc509a0925d0b1fc4\n42ca034f224732e429081da1b621f55a ... Hash (TXID)\n\n01000000 ........................... Type: MSG_TX\n91d36d997037e08018262978766f24b8\na055aaf1d872e94ae85e9817b2c68dc7 ... Hash (TXID)", 
            "title": "Inv"
        }, 
        {
            "location": "/p2p/#mempool", 
            "text": "The  mempool  message requests the TXIDs of transactions that the\nreceiving node has verified as valid but which have not yet appeared in\na block. That is, transactions which are in the receiving node's memory\npool. The response to the  mempool  message is one or more  inv \nmessages containing the TXIDs in the usual inventory format.  Sending the  mempool  message is mostly useful when a program first\nconnects to the network. Full nodes can use it to quickly gather most or\nall of the unconfirmed transactions available on the network; this is\nespecially useful for miners trying to gather transactions for their\ntransaction fees. SPV clients can set a filter before sending a mempool  to only receive transactions that match that filter; this\nallows a recently-started client to get most or all unconfirmed\ntransactions related to its wallet.  The  inv  response to the  mempool  message is, at best, one node's\nview of the network---not a complete list of unconfirmed transactions\non the network. Here are some additional reasons the list might not\nbe complete:    Before Bitcoin Core 0.9.0, the response to the  mempool  message was\n  only one  inv  message. An  inv  message is limited to 50,000\n  inventories, so a node with a memory pool larger than 50,000 entries\n  would not send everything.  Later versions of Bitcoin Core send as\n  many  inv  messages as needed to reference its complete memory pool.    The  mempool  message is not currently fully compatible with the\n   filterload  message's  BLOOM_UPDATE_ALL  and\n   BLOOM_UPDATE_P2PUBKEY_ONLY  flags. Mempool transactions are not\n  sorted like in-block transactions, so a transaction (tx2) spending an\n  output can appear before the transaction (tx1) containing that output,\n  which means the automatic filter update mechanism won't operate until\n  the second-appearing transaction (tx1) is seen---missing the\n  first-appearing transaction (tx2). It has been proposed in [Bitcoin\n  Core issue #2381][] that the transactions should be sorted before\n  being processed by the filter.    There is no payload in a  mempool  message.  See the [message header\nsection][section message header] for an example of a message without a payload.", 
            "title": "MemPool"
        }, 
        {
            "location": "/p2p/#merkleblock", 
            "text": "The  merkleblock  message is a reply to a  getdata  message which\nrequested a block using the inventory type  MSG_MERKLEBLOCK .  It is\nonly part of the reply: if any matching transactions are found, they will\nbe sent separately as  tx  messages.  If a filter has been previously set with the  filterload  message, the merkleblock  message will contain the TXIDs of any transactions in the\nrequested block that matched the filter, as well as any parts of the\nblock's merkle tree necessary to connect those transactions to the\nblock header's merkle root. The message also contains a complete copy\nof the block header to allow the client to hash it and confirm its\nproof of work.     Bytes  Name  Data Type  Description      80  block header  block_header  The block header in the format described in the  block header section .    4  transaction count  uint32_t  The number of transactions in the block (including ones that don't match the filter).    Varies  hash count  compactSize uint  The number of hashes in the following field.    Varies  hashes  char[32]  One or more hashes of both transactions and merkle nodes in internal byte order.  Each hash is 32 bytes.    Varies  flag byte count  compactSize uint  The number of flag bytes in the following field.    Varies  flags  byte[]  A sequence of bits packed eight in a byte with the least significant bit first.  May be padded to the nearest byte boundary but must not contain any more bits than that.  Used to assign the hashes to particular nodes in the merkle tree as described below.     The annotated hexdump below shows a  merkleblock  message which\ncorresponds to the examples below.  (The message header has been\nomitted.)  01000000 ........................... Block version: 1\n82bb869cf3a793432a66e826e05a6fc3\n7469f8efb7421dc88067010000000000 ... Hash of previous block's header\n7f16c5962e8bd963659c793ce370d95f\n093bc7e367117b3c30c1f8fdd0d97287 ... Merkle root\n76381b4d ........................... Time: 1293629558\n4c86041b ........................... nBits: 0x04864c * 256**(0x1b-3)\n554b8529 ........................... Nonce\n\n07000000 ........................... Transaction count: 7\n04 ................................. Hash count: 4\n\n3612262624047ee87660be1a707519a4\n43b1c1ce3d248cbfc6c15870f6c5daa2 ... Hash #1\n019f5b01d4195ecbc9398fbf3c3b1fa9\nbb3183301d7a1fb3bd174fcfa40a2b65 ... Hash #2\n41ed70551dd7e841883ab8f0b16bf041\n76b7d1480e4f0af9f3d4c3595768d068 ... Hash #3\n20d2a7bc994987302e5b1ac80fc425fe\n25f8b63169ea78e68fbaaefa59379bbf ... Hash #4\n\n01 ................................. Flag bytes: 1\n1d ................................. Flags: 1 0 1 1 1 0 0 0  Note: when fully decoded, the above  merkleblock  message provided the\nTXID for a single transaction that matched the filter. In the network\ntraffic dump this output was taken from, the full transaction belonging\nto that TXID was sent immediately after the  merkleblock  message as\na  tx  message.", 
            "title": "MerkleBlock"
        }, 
        {
            "location": "/p2p/#parsing-a-merkleblock-message", 
            "text": "As seen in the annotated hexdump above, the  merkleblock  message\nprovides three special data types: a transaction count, a list of\nhashes, and a list of one-bit flags.  You can use the transaction count to construct an empty merkle tree.\nWe'll call each entry in the tree a node; on the bottom are TXID\nnodes---the hashes for these nodes are TXIDs; the remaining nodes\n(including the merkle root) are non-TXID nodes---they may actually have\nthe same hash as a TXID, but we treat them differently.   Keep the hashes and flags in the order they appear in the  merkleblock \nmessage. When we say \"next flag\" or \"next hash\", we mean the next flag\nor hash on the list, even if it's the first one we've used so far.  Start with the merkle root node and the first flag. The table below\ndescribes how to evaluate a flag based on whether the node being\nprocessed is a TXID node or a non-TXID node. Once you apply a flag to a\nnode, never apply another flag to that same node or reuse that same\nflag again.     Flag  TXID Node  Non-TXID Node      0  Use the next hash as this node's TXID, but this transaction didn't match the filter.  Use the next hash as this node's hash.  Don't process any descendant nodes.    1  Use the next hash as this node's TXID, and mark this transaction as matching the filter.  The hash needs to be computed.  Process the left child node to get its hash; process the right child node to get its hash; then concatenate the two hashes as 64 raw bytes and hash them to get this node's hash.     Any time you begin processing a node for the first time, evaluate the next\nflag. Never use a flag at any other time.  When processing a child node, you may need to process its children (the\ngrandchildren of the original node) or further-descended nodes before\nreturning to the parent node. This is expected---keep processing depth\nfirst until you reach a TXID node or a non-TXID node with a flag of 0.  After you process a TXID node or a non-TXID node with a flag of 0, stop\nprocessing flags and begin to ascend the tree. As you ascend, compute\nthe hash of any nodes for which you now have both child hashes or for\nwhich you now have the sole child hash. See the [merkle tree\nsection][section merkle trees] for hashing instructions. If you reach a\nnode where only the left hash is known, descend into its right child (if\npresent) and further descendants as necessary.  However, if you find a node whose left and right children both have the\nsame hash, fail.  This is related to CVE-2012-2459.  Continue descending and ascending until you have enough information to\nobtain the hash of the merkle root node. If you run out of flags or\nhashes before that condition is reached, fail. Then perform the\nfollowing checks (order doesn't matter):    Fail if there are unused hashes in the hashes list.    Fail if there are unused flag bits---except for the minimum number of\n  bits necessary to pad up to the next full byte.    Fail if the hash of the merkle root node is not identical to the\n  merkle root in the block header.    Fail if the block header is invalid. Remember to ensure that the hash\n  of the header is less than or equal to the target threshold encoded by\n  the nBits header field. Your program should also, of course, attempt\n  to ensure the header belongs to the best block chain and that the user\n  knows how many confirmations this block has.    For a detailed example of parsing a  merkleblock  message, please see\nthe corresponding [merkle block examples section][section merkleblock\nexample].", 
            "title": "Parsing A MerkleBlock Message"
        }, 
        {
            "location": "/p2p/#creating-a-merkleblock-message", 
            "text": "It's easier to understand how to create a  merkleblock  message after\nyou understand how to parse an already-created message, so we recommend\nyou read the parsing section above first.  Create a complete merkle tree with TXIDs on the bottom row and all the\nother hashes calculated up to the merkle root on the top row. For each\ntransaction that matches the filter, track its TXID node and all of its\nancestor nodes.   Start processing the tree with the merkle root node. The table below\ndescribes how to process both TXID nodes and non-TXID nodes based on\nwhether the node is a match, a match ancestor, or neither a match nor a\nmatch ancestor.      TXID Node  Non-TXID Node      Neither Match Nor Match Ancestor  Append a 0 to the flag list; append this node's TXID to the hash list.  Append a 0 to the flag list; append this node's hash to the hash list.  Do not descend into its child nodes.    Match Or Match Ancestor  Append a 1 to the flag list; append this node's TXID to the hash list.  Append a 1 to the flag list; process the left child node.  Then, if the node has a right child, process the right child.  Do not append a hash to the hash list for this node.     Any time you begin processing a node for the first time, a flag should be\nappended to the flag list. Never put a flag on the list at any other\ntime, except when processing is complete to pad out the flag list to a\nbyte boundary.  When processing a child node, you may need to process its children (the\ngrandchildren of the original node) or further-descended nodes before\nreturning to the parent node. This is expected---keep processing depth\nfirst until you reach a TXID node or a node which is neither a TXID nor\na match ancestor.  After you process a TXID node or a node which is neither a TXID nor a\nmatch ancestor, stop processing and begin to ascend the tree until you\nfind a node with a right child you haven't processed yet. Descend into\nthat right child and process it.  After you fully process the merkle root node according to the\ninstructions in the table above, processing is complete.  Pad your flag\nlist to a byte boundary and construct the  merkleblock  message using the\ntemplate near the beginning of this subsection.", 
            "title": "Creating A MerkleBlock Message"
        }, 
        {
            "location": "/p2p/#notfound", 
            "text": "The  notfound  message is a reply to a  getdata  message which\nrequested an object the receiving node does not have available for\nrelay. (Nodes are not expected to relay historic transactions which\nare no longer in the memory pool or relay set. Nodes may also have\npruned spent transactions from older blocks, making them unable to\nsend those blocks.)  The format and maximum size limitations of the  notfound  message are\nidentical to the  inv  message; only the message header differs.", 
            "title": "NotFound"
        }, 
        {
            "location": "/p2p/#tx", 
            "text": "The  tx  message transmits a single transaction in the raw transaction\nformat. It can be sent in a variety of situations;    Transaction Response:  Bitcoin Core and BitcoinJ will send it in\n  response to a  getdata  message that requests the transaction with an\n  inventory type of  MSG_TX .    MerkleBlock Response:  Bitcoin Core will send it in response to a\n   getdata  message that requests a merkle block with an inventory type\n  of  MSG_MERKLEBLOCK . (This is in addition to sending a  merkleblock \n  message.) Each  tx  message in this case provides a matched\n  transaction from that block.    Unsolicited:  BitcoinJ will send a  tx  message unsolicited for\n  transactions it originates.    For an example hexdump of the raw transaction format, see the  raw\ntransaction section .", 
            "title": "Tx"
        }, 
        {
            "location": "/p2p/#control-messages", 
            "text": "The following network messages all help control the connection between\ntwo peers or allow them to advise each other about the rest of the\nnetwork.   Note that almost none of the control messages are authenticated in any\nway, meaning they can contain incorrect or intentionally harmful\ninformation. In addition, this section does not yet cover P2P protocol\noperation over the Tor network; if you would like to contribute\ninformation about Tor, please open an issue.", 
            "title": "Control Messages"
        }, 
        {
            "location": "/p2p/#addr", 
            "text": "The  addr  (IP address) message relays connection information\nfor peers on the network. Each peer which wants to accept incoming\nconnections creates an  addr  message providing its connection\ninformation and then sends that message to its peers unsolicited. Some\nof its peers send that information to their peers (also unsolicited),\nsome of which further distribute it, allowing decentralized peer\ndiscovery for any program already on the network.  An  addr  message may also be sent in response to a  getaddr  message.     Bytes  Name  Data Type  Description      Varies  IP address count  compactSize uint  The number of IP address entries up to a maximum of 1,000.    Varies  IP addresses  network IP address  IP address entries.  See the table below for the format of a Bitcoin network IP address.     Each encapsulated network IP address currently uses the following structure:     Bytes  Name  Data Type  Description      4  time  uint32  Added in protocol version 31402.   A time in Unix epoch time format.  Nodes advertising their own IP address set this to the current time.  Nodes advertising IP addresses they've connected to set this to the last time they connected to that node.  Other nodes just relaying the IP address should not change the time.  Nodes can use the time field to avoid relaying old  addr  messages.   Malicious nodes may change times or even set them in the future.    8  services  uint64_t  The services the node advertised in its  version  message.    16  IP address  char  IPv6 address in  big endian byte order . IPv4 addresses can be provided as IPv4-mapped IPv6 addresses    2  port  uint16_t  Port number in  big endian byte order .  Note that Bitcoin Core will only connect to nodes with non-standard port numbers as a last resort for finding peers.  This is to prevent anyone from trying to use the network to disrupt non-Bitcoin services that run on other ports.     The following annotated hexdump shows part of an  addr  message. (The\nmessage header has been omitted and the actual IP address has been\nreplaced with a RFC5737 reserved IP address.)  fde803 ............................. Address count: 1000\n\nd91f4854 ........................... Epoch time: 1414012889\n0100000000000000 ................... Service bits: 01 (network node)\n00000000000000000000ffffc0000233 ... IP Address: ::ffff:192.0.2.51\n208d ............................... Port: 8333\n\n[...] .............................. (999 more addresses omitted)", 
            "title": "Addr"
        }, 
        {
            "location": "/p2p/#feefilter", 
            "text": "The  feefilter  message is a request to the receiving peer to not relay any\ntransaction inv messages to the sending peer where the fee rate for the\ntransaction is below the fee rate specified in the feefilter message.  feefilter  was introduced in Bitcoin Core 0.13.0 following the introduction\nof mempool limiting in Bitcoin Core 0.12.0. Mempool limiting provides protection against\nattacks and spam transactions that have low fee rates and are unlikely to be\nincluded in mined blocks. The  feefilter  messages allows a node to inform its\npeers that it will not accept transactions below a specified fee rate into\nits mempool, and therefore that the peers can skip relaying inv messages for\ntransactions below that fee rate to that node.     Bytes  Name  Data Type  Description      8  feerate  uint64_t  The fee rate (in satoshis per kilobyte) below which transactions should not be relayed to this peer.     The receiving peer may choose to ignore the message and not filter transaction\ninv messages.  The fee filter is additive with bloom filters. If an SPV client loads a bloom\nfilter and sends a feefilter message, transactions should only be relayed if\nthey pass both filters.  Note however that feefilter has no effect on block propagation or responses to\ngetdata messages. For example, if a node requests a merkleblock from its peer\nby sending a getdata message with inv type MSG_FILTERED_BLOCK and it has\npreviously sent a feefilter to that peer, the peer should respond with a\nmerkleblock containing  all  the transactions matching the bloom filter, even\nif they are below the feefilter fee rate.  inv messages generated from a mempool message are subject to a fee filter if it exists.  The annotated hexdump below shows a  feefilter  message. (The message\nheader has been omitted.)  7cbd000000000000 ... satoshis per kilobyte: 48,508", 
            "title": "FeeFilter"
        }, 
        {
            "location": "/p2p/#filteradd", 
            "text": "The  filteradd  message tells the receiving peer to add a single element to\na previously-set bloom filter, such as a new public key. The element is\nsent directly to the receiving peer; the peer then uses the parameters set\nin the  filterload  message to add the element to the bloom filter.  Because the element is sent directly to the receiving peer, there is no\nobfuscation of the element and none of the plausible-deniability privacy\nprovided by the bloom filter. Clients that want to maintain greater\nprivacy should recalculate the bloom filter themselves and send a new filterload  message with the recalculated bloom filter.     Bytes  Name  Data Type  Description      Varies  element bytes  compactSize uint  The number of bytes in the following element field.    Varies  element  uint8_t[]  The element to add to the current filter.  Maximum of 520 bytes, which is the maximum size of an element which can be pushed onto the stack in a pubkey or signature script.  Elements must be sent in the byte order they would use when appearing in a raw transaction; for example, hashes should be sent in internal byte order.     Note: a  filteradd  message will not be accepted unless a filter was\npreviously set with the  filterload  message.  The annotated hexdump below shows a  filteradd  message adding a TXID.\n(The message header has been omitted.) This TXID appears in the same\nblock used for the example hexdump in the  merkleblock  message; if that merkleblock  message is re-sent after sending this  filteradd  message,\nsix hashes are returned instead of four.  20 ................................. Element bytes: 32\nfdacf9b3eb077412e7a968d2e4f11b9a\n9dee312d666187ed77ee7d26af16cb0b ... Element (A TXID)", 
            "title": "FilterAdd"
        }, 
        {
            "location": "/p2p/#filterclear", 
            "text": "The  filterclear  message tells the receiving peer to remove a\npreviously-set bloom filter.  This also undoes the effect of setting the\nrelay field in the  version  message to 0, allowing unfiltered access to inv  messages announcing new transactions.  Bitcoin Core does not require a  filterclear  message before a\nreplacement filter is loaded with  filterload .  It also doesn't require\na  filterload  message before a  filterclear  message.  There is no payload in a  filterclear  message.  See the [message header\nsection][section message header] for an example of a message without a payload.", 
            "title": "FilterClear"
        }, 
        {
            "location": "/p2p/#filterload", 
            "text": "The  filterload  message tells the receiving peer to filter all relayed\ntransactions and requested merkle blocks through the provided filter.\nThis allows clients to receive transactions relevant to their wallet\nplus a configurable rate of false positive transactions which can\nprovide plausible-deniability privacy.     Bytes  Name  Data Type  Description      Varies  nFilterBytes  compactSize uint  Number of bytes in the following filter bit field.    Varies  filter  uint8_t[]  A bit field of arbitrary byte-aligned size. The maximum size is 36,000 bytes.    4  nHashFuncs  uint32_t  The number of hash functions to use in this filter. The maximum value allowed in this field is 50.    4  nTweak  uint32_t  An arbitrary value to add to the seed value in the hash function used by the bloom filter.    1  nFlags  uint8_t  A set of flags that control how outpoints corresponding to a matched pubkey script are added to the filter. See the table in the Updating A Bloom Filter subsection below.     The annotated hexdump below shows a  filterload  message. (The message\nheader has been omitted.)  For an example of how this payload was\ncreated, see the filterload example.  02 ......... Filter bytes: 2\nb50f ....... Filter: 1010 1101 1111 0000\n0b000000 ... nHashFuncs: 11\n00000000 ... nTweak: 0/none\n00 ......... nFlags: BLOOM_UPDATE_NONE  Initializing A Bloom Filter  Filters have two core parameters: the size of the bit field and the\nnumber of hash functions to run against each data element. The following\nformulas from BIP37 will allow you to automatically select appropriate\nvalues based on the number of elements you plan to insert into the\nfilter ( n ) and the false positive rate ( p ) you desire to maintain\nplausible deniability.    Size of the bit field in bytes ( nFilterBytes ), up to a maximum of\n  36,000:  (-1 / log(2)**2 * n * log(p)) / 8    Hash functions to use ( nHashFuncs ), up to a maximum of 50:\n   nFilterBytes * 8 / n * log(2)    Note that the filter matches parts of transactions (transaction\nelements), so the false positive rate is relative to the number of\nelements checked---not the number of transactions checked. Each normal\ntransaction has a minimum of four matchable elements (described in the\ncomparison subsection below), so a filter with a false-positive rate of\n1 percent will match about 4 percent of all transactions at a minimum.  According to BIP37, the formulas and limits described above provide\nsupport for bloom filters containing 20,000 items with a false positive\nrate of less than 0.1 percent or 10,000 items with a false positive rate\nof less than 0.0001 percent.  Once the size of the bit field is known, the bit field should be\ninitialized as all zeroes.  Populating A Bloom Filter  The bloom filter is populated using between 1 and 50 unique hash\nfunctions (the number specified per filter by the  nHashFuncs \nfield). Instead of using up to 50 different hash function\nimplementations, a single implementation is used with a unique seed\nvalue for each function.  The seed is  nHashNum * 0xfba4c795 + nTweak  as a  uint32_t , where the values\nare:    nHashNum  is the sequence number for this hash\n  function, starting at 0 for the first hash iteration and increasing up\n  to the value of the  nHashFuncs  field (minus one) for the last hash\n  iteration.    0xfba4c795  is a constant optimized to create large differences in\n  the seed for different values of  nHashNum .    nTweak  is a per-filter constant set by the client to require the use\n  of an arbitrary set of hash functions.    If the seed resulting from the formula above is larger than four bytes,\nit must be truncated to its four most significant bytes (for example, 0x8967452301   0xffffffff \u2192 0x67452301 ).  The actual hash function implementation used is the [32-bit Murmur3 hash\nfunction][murmur3].   Warning:  the Murmur3 hash function has separate 32-bit and 64-bit\nversions that produce different results for the same input.  Only the\n32-bit Murmur3 version is used with Bitcoin bloom filters.  The data to be hashed can be any transaction element which the bloom\nfilter can match. See the next subsection for the list of transaction\nelements checked against the filter. The largest element which can be\nmatched is a script data push of 520 bytes, so the data should never\nexceed 520 bytes.  The example below from Bitcoin Core [bloom.cpp][core bloom.cpp hash] combines\nall the steps above to create the hash function template. The seed is\nthe first parameter; the data to be hashed is the second parameter. The\nresult is a uint32_t modulo the size of the bit field in bits.  {% highlight c++ %}\nMurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8)\n{% endhighlight %}  Each data element to be added to the filter is hashed by  nHashFuncs \nnumber of hash functions. Each time a hash function is run, the result\nwill be the index number ( nIndex ) of a bit in the bit field. That bit\nmust be set to 1. For example if the filter bit field was  00000000  and\nthe result is 5, the revised filter bit field is  00000100  (the first bit\nis bit 0).  It is expected that sometimes the same index number will be returned\nmore than once when populating the bit field; this does not affect the\nalgorithm---after a bit is set to 1, it is never changed back to 0.  After all data elements have been added to the filter, each set of eight\nbits is converted into a little-endian byte. These bytes are the value\nof the  filter  field.  Comparing Transaction Elements To A Bloom Filter  To compare an arbitrary data element against the bloom filter, it is\nhashed using the same parameters used to create the bloom filter.\nSpecifically, it is hashed  nHashFuncs  times, each time using the same nTweak  provided in the filter, and the resulting output is modulo the\nsize of the bit field provided in the  filter  field.  After each hash is\nperformed, the filter is checked to see if the bit at that indexed\nlocation is set.  For example if the result of a hash is  5  and the\nfilter is  01001110 , the bit is considered set.  If the result of every hash points to a set bit, the filter matches. If\nany of the results points to an unset bit, the filter does not match.  The following transaction elements are compared against bloom filters.\nAll elements will be hashed in the byte order used in blocks (for\nexample, TXIDs will be in internal byte order).    TXIDs:  the transaction's SHA256(SHA256()) hash.    Outpoints:  each 36-byte outpoint used this transaction's input\n  section is individually compared to the filter.    Signature Script Data:  each element pushed onto the stack by a\n  data-pushing opcode in a signature script from this transaction is\n  individually compared to the filter.  This includes data elements\n  present in P2SH redeem scripts when they are being spent.    PubKey Script Data:  each element pushed onto the the stack by a\n  data-pushing opcode in any pubkey script from this transaction is\n  individually compared to the filter. (If a pubkey script element\n  matches the filter, the filter will be immediately updated if the\n   BLOOM_UPDATE_ALL  flag was set; if the pubkey script is in the P2PKH\n  format and matches the filter, the filter will be immediately updated\n  if the  BLOOM_UPDATE_P2PUBKEY_ONLY  flag was set. See the subsection\n  below for details.)    The following annotated hexdump of a transaction is from the [raw\ntransaction format section][raw transaction format]; the elements which\nwould be checked by the filter are emphasized in bold. Note that this\ntransaction's TXID ( 01000000017b1eab[...] ) would also be checked,\nand that the outpoint TXID and index number below would be checked as a\nsingle 36-byte element.  01000000 ................................... Version\n\n01 ......................................... Number of inputs\n|\n|  7b1eabe0209b1fe794124575ef807057 \n|  c77ada2138ae4fa8d6c4de0398a14f3f  ......... Outpoint TXID\n|  00000000  ................................. Outpoint index number\n|\n| 49 ....................................... Bytes in sig. script: 73\n| | 48 ..................................... Push 72 bytes as data\n| | |  30450221008949f0cb400094ad2b5eb3 \n| | |  99d59d01c14d73d8fe6e96df1a7150de \n| | |  b388ab8935022079656090d7f6bac4c9 \n| | |  a94e0aad311a4268e082a725f8aeae05 \n| | |  73fb12ff866a5f01  ..................... Secp256k1 signature\n|\n| ffffffff ................................. Sequence number: UINT32_MAX\n\n01 ......................................... Number of outputs\n| f0ca052a01000000 ......................... Satoshis (49.99990000 BTC)\n|\n| 19 ....................................... Bytes in pubkey script: 25\n| | 76 ..................................... OP_DUP\n| | a9 ..................................... OP_HASH160\n| | 14 ..................................... Push 20 bytes as data\n| | |  cbc20a7664f2f69e5355aa427045bc15 \n| | |  e7c6c772  ............................. PubKey hash\n| | 88 ..................................... OP_EQUALVERIFY\n| | ac ..................................... OP_CHECKSIG\n\n00000000 ................................... locktime: 0 (a block height)  Updating A Bloom Filter  Clients will often want to track inputs that spend outputs (outpoints)\nrelevant to their wallet, so the filterload field  nFlags  can be set to\nallow the filtering node to update the filter when a match is found.\nWhen the filtering node sees a pubkey script that pays a pubkey,\naddress, or other data element matching the filter, the filtering node\nimmediately updates the filter with the outpoint corresponding to that\npubkey script.   If an input later spends that outpoint, the filter will match it,\nallowing the filtering node to tell the client that one of its\ntransaction outputs has been spent.  The  nFlags  field has three allowed values:     Value  Name  Description      0  BLOOM_UPDATE_NONE  The filtering node should not update the filter.    1  BLOOM_UPDATE_ALL  If the filter matches any data element in a pubkey script, the corresponding outpoint is added to the filter.    2  BLOOM_UPDATE_P2PUBKEY_ONLY  If the filter matches any data element in a pubkey script and that script is either a P2PKH or non-P2SH pay-to-multisig script, the corresponding outpoint is added to the filter.     In addition, because the filter size stays the same even though\nadditional elements are being added to it, the false positive rate\nincreases. Each false positive can result in another element being added\nto the filter, creating a feedback loop that can (after a certain point)\nmake the filter useless. For this reason, clients using automatic filter\nupdates need to monitor the actual false positive rate and send a new\nfilter when the rate gets too high.  {% endautocrossref %}", 
            "title": "FilterLoad"
        }, 
        {
            "location": "/p2p/#getaddr", 
            "text": "{% include helpers/subhead-links.md %}  {% autocrossref %}  The  getaddr  message requests an  addr  message from the receiving\nnode, preferably one with lots of IP addresses of other receiving nodes.\nThe transmitting node can use those IP addresses to quickly update its\ndatabase of available nodes rather than waiting for unsolicited  addr \nmessages to arrive over time.  There is no payload in a  getaddr  message.  See the [message header\nsection][section message header] for an example of a message without a payload.  {% endautocrossref %}", 
            "title": "GetAddr"
        }, 
        {
            "location": "/p2p/#ping", 
            "text": "{% include helpers/subhead-links.md %}  {% autocrossref %}  The  ping  message helps confirm that the receiving peer is still\nconnected. If a TCP/IP error is encountered when sending the  ping \nmessage (such as a connection timeout), the transmitting node can assume\nthat the receiving node is disconnected. The response to a  ping \nmessage is the  pong  message.  Before protocol version 60000, the  ping  message had no payload. As of\nprotocol version 60001 and all later versions, the message includes a\nsingle field, the nonce.     Bytes  Name  Data Type  Description      8  nonce  uint64_t  Added in protocol version 60001 as described by BIP31.   Random nonce assigned to this  ping  message.  The responding  pong  message will include this nonce to identify the  ping  message to which it is replying.     The annotated hexdump below shows a  ping  message. (The message\nheader has been omitted.)  {% highlight text %}\n0094102111e2af4d ... Nonce\n{% endhighlight %}  {% endautocrossref %}", 
            "title": "Ping"
        }, 
        {
            "location": "/p2p/#pong", 
            "text": "{% include helpers/subhead-links.md %}  {% autocrossref %}  Added in protocol version 60001 as described by BIP31.  The  pong  message replies to a  ping  message, proving to the pinging\nnode that the ponging node is still alive. Bitcoin Core will, by\ndefault, disconnect from any clients which have not responded to a ping  message within 20 minutes.  To allow nodes to keep track of latency, the  pong  message sends back\nthe same nonce received in the  ping  message it is replying to.  The format of the  pong  message is identical to the  ping  message;\nonly the message header differs.  {% endautocrossref %}", 
            "title": "Pong"
        }, 
        {
            "location": "/p2p/#reject", 
            "text": "{% include helpers/subhead-links.md %}  {% autocrossref %}  Added in protocol version 70002 as described by BIP61.  The  reject  message informs the receiving node that one of its previous\nmessages has been rejected.     Bytes  Name  Data Type  Description      Varies  message bytes  compactSize uint  The number of bytes in the following message field.    Varies  message  string  The type of message rejected as ASCII text  without null padding .  For example: \"tx\", \"block\", or \"version\".    1  code  char  The reject message code.  See the table below.    Varies  reason bytes  compactSize uint  The number of bytes in the following reason field.  May be 0x00 if a text reason isn't provided.    Varies  reason  string  The reason for the rejection in ASCII text.  This should not be displayed to the user; it is only for debugging purposes.    Varies  extra data  varies  Optional additional data provided with the rejection.  For example, most rejections of  tx  messages or  block  messages include the hash of the rejected transaction or block header.  See the code table below.     The following table lists message reject codes.  Codes are tied to the\ntype of message they reply to; for example there is a 0x10 reject code\nfor transactions and a 0x10 reject code for blocks.      Code  In Reply To  Extra Bytes  Extra Type  Description      0x01  any message  0  N/A  Message could not be decoded.  Be careful of  reject  message feedback loops where two peers each don't understand each other's  reject  messages and so keep sending them back and forth forever.    0x10  block  message  32  char[32]  Block is invalid for some reason (invalid proof-of-work, invalid signature, etc).  Extra data may include the rejected block's header hash.    0x10  tx  message  32  char[32]  Transaction is invalid for some reason (invalid signature, output value greater than input, etc.).  Extra data may include the rejected transaction's TXID.    0x11  block  message  32  char[32]  The block uses a version that is no longer supported.  Extra data may include the rejected block's header hash.    0x11  version  message  0  N/A  Connecting node is using a protocol version that the rejecting node considers obsolete and unsupported.    0x12  tx  message  32  char[32]  Duplicate input spend (double spend): the rejected transaction spends the same input as a previously-received transaction.  Extra data may include the rejected transaction's TXID.    0x12  version  message  0  N/A  More than one  version  message received in this connection.    0x40  tx  message  32  char[32]  The transaction will not be mined or relayed because the rejecting node considers it non-standard---a transaction type or version unknown by the server.  Extra data may include the rejected transaction's TXID.    0x41  tx  message  32  char[32]  One or more output amounts are below the dust threshold.  Extra data may include the rejected transaction's TXID.    0x42  tx  message   char[32]  The transaction did not have a large enough fee or priority to be relayed or mined.  Extra data may include the rejected transaction's TXID.    0x43  block  message  32  char[32]  The block belongs to a block chain which is not the same block chain as provided by a compiled-in checkpoint.  Extra data may include the rejected block's header hash.     The annotated hexdump below shows a  reject  message. (The message\nheader has been omitted.)  {% highlight text %}\n02 ................................. Number of bytes in message: 2\n7478 ............................... Type of message rejected: tx\n12 ................................. Reject code: 0x12 (duplicate)\n15 ................................. Number of bytes in reason: 21\n6261642d74786e732d696e707574732d\n7370656e74 ......................... Reason: bad-txns-inputs-spent\n394715fcab51093be7bfca5a31005972\n947baf86a31017939575fb2354222821 ... TXID\n{% endhighlight %}  {% endautocrossref %}", 
            "title": "Reject"
        }, 
        {
            "location": "/p2p/#sendheaders", 
            "text": "{% include helpers/subhead-links.md %}  {% autocrossref %}  The  sendheaders  message tells the receiving peer to send new block\nannouncements using a  headers  message rather than an  inv  message.  There is no payload in a  sendheaders  message.  See the [message header\nsection][section message header] for an example of a message without a payload.  {% endautocrossref %}", 
            "title": "SendHeaders"
        }, 
        {
            "location": "/p2p/#verack", 
            "text": "{% include helpers/subhead-links.md %}  {% autocrossref %}  Added in protocol version 209.  The  verack  message acknowledges a previously-received  version \nmessage, informing the connecting node that it can begin to send\nother messages. The  verack  message has no payload; for an example\nof a message with no payload, see the [message headers\nsection][section message header].  {% endautocrossref %}", 
            "title": "VerAck"
        }, 
        {
            "location": "/p2p/#version", 
            "text": "{% include helpers/subhead-links.md %}  {% autocrossref %}  The  version  message provides information about the transmitting node\nto the receiving node at the beginning of a connection. Until both peers\nhave exchanged  version  messages, no other messages will be accepted.  If a  version  message is accepted, the receiving node should send a verack  message---but no node should send a  verack  message\nbefore initializing its half of the connection by first sending a version  message.     Bytes  Name  Data Type  Required/Optional  Description      4  version  int32_t  Required  The highest protocol version understood by the transmitting node.  See the [protocol version section][section protocol versions].    8  services  uint64_t  Required  The services supported by the transmitting node encoded as a bitfield.  See the list of service codes below.    8  timestamp  int64_t  Required  The current Unix epoch time according to the transmitting node's clock.  Because nodes will reject blocks with timestamps more than two hours in the future, this field can help other nodes to determine that their clock is wrong.    8  addr_recv services  uint64_t  Required  The services supported by the receiving node as perceived by the transmitting node.  Same format as the 'services' field above. Bitcoin Core will attempt to provide accurate information.  BitcoinJ will, by default, always send 0.    16  addr_recv IP address  char  Required  The IPv6 address of the receiving node as perceived by the transmitting node in  big endian byte order . IPv4 addresses can be provided as [IPv4-mapped IPv6 addresses][]. Bitcoin Core will attempt to provide accurate information.  BitcoinJ will, by default, always return ::ffff:127.0.0.1    2  addr_recv port  uint16_t  Required  The port number of the receiving node as perceived by the transmitting node in  big endian byte order .    8  addr_trans services  uint64_t  Required  Added in protocol version 106.   The services supported by the transmitting node.  Should be identical to the 'services' field above.    16  addr_trans IP address  char  Required  Added in protocol version 106.   The IPv6 address of the transmitting node in  big endian byte order . IPv4 addresses can be provided as [IPv4-mapped IPv6 addresses][].  Set to ::ffff:127.0.0.1 if unknown.    2  addr_trans port  uint16_t  Required  Added in protocol version 106.   The port number of the transmitting node in  big endian byte order .    8  nonce  uint64_t  Required  Added in protocol version 106.   A random nonce which can help a node detect a connection to itself.  If the nonce is 0, the nonce field is ignored.  If the nonce is anything else, a node should terminate the connection on receipt  of a  version  message with a nonce it previously sent.    Varies  user_agent bytes  compactSize uint  Required  Added in protocol version 106.   Number of bytes in following user_agent field.  If 0x00, no user agent field is sent.    Varies  user_agent  string  Required if user_agent bytes   0  Added in protocol version 106. Renamed in protocol version 60000.   User agent as defined by BIP14. Previously called subVer.    4  start_height  int32_t  Required  Added in protocol version 209.   The height of the transmitting node's best block chain or, in the case of an SPV client, best block header chain.    1  relay  bool  Optional  Added in protocol version 70001 as described by BIP37.   Transaction relay flag.  If 0x00, no  inv  messages or  tx  messages announcing new transactions should be sent to this client until it sends a  filterload  message or  filterclear  message.  If the relay field is not present or is set to 0x01, this node wants  inv  messages and  tx  messages announcing new transactions.     The following service identifiers have been assigned.     Value  Name  Description      0x00  Unnamed  This node is not a full node.  It may not be able to provide any data except for the transactions it originates.    0x01  NODE_NETWORK  This is a full node and can be asked for full blocks.  It should implement all protocol features available in its self-reported protocol version.     The following annotated hexdump shows a  version  message. (The\nmessage header has been omitted and the actual IP addresses have been\nreplaced with [RFC5737][] reserved IP addresses.)  {% highlight text %}\n72110100 ........................... Protocol version: 70002\n0100000000000000 ................... Services: NODE_NETWORK\nbc8f5e5400000000 ................... Epoch time: 1415483324  0100000000000000 ................... Receiving node's services\n00000000000000000000ffffc61b6409 ... Receiving node's IPv6 address\n208d ............................... Receiving node's port number  0100000000000000 ................... Transmitting node's services\n00000000000000000000ffffcb0071c0 ... Transmitting node's IPv6 address\n208d ............................... Transmitting node's port number  128035cbc97953f8 ................... Nonce  0f ................................. Bytes in user agent string: 15\n2f5361746f7368693a302e392e332f ..... User agent: /Satoshi:0.9.3/  cf050500 ........................... Start height: 329167\n01 ................................. Relay flag: true\n{% endhighlight %}  {% endautocrossref %}", 
            "title": "Version"
        }, 
        {
            "location": "/api/", 
            "text": "", 
            "title": "Pinkcoin API"
        }
    ]
}